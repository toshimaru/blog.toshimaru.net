<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://blog.toshimaru.net/feed/by_tag/go.xml" rel="self" type="application/atom+xml" /><link href="https://blog.toshimaru.net/" rel="alternate" type="text/html" /><updated>2024-02-06T13:03:33+09:00</updated><id>https://blog.toshimaru.net/feed/by_tag/go.xml</id><title type="html">Hack Your Design!</title><subtitle>toshimaruの技術系なブログ</subtitle><author><name>Toshimaru</name></author><entry><title type="html">Dependabot で go modules の自動アップデートをする（go mod tidy付き）</title><link href="https://blog.toshimaru.net/dependabot-gomod/" rel="alternate" type="text/html" title="Dependabot で go modules の自動アップデートをする（go mod tidy付き）" /><published>2021-01-27T00:00:00+09:00</published><updated>2021-01-27T00:00:00+09:00</updated><id>https://blog.toshimaru.net/dependabot-gomod</id><content type="html" xml:base="https://blog.toshimaru.net/dependabot-gomod/"><![CDATA[<p>Dependabot が GitHub の公式機能の一部として利用可能になりました。</p>

<blockquote class="twitter-tweet"><p lang="ja" dir="ltr">blogged. | DependabotをGitHub公式Dependabotに移行させた - Hack Your Design! <a href="https://t.co/6Mb0XDSaSC">https://t.co/6Mb0XDSaSC</a></p>&mdash; toshimaru (@toshimaru_e) <a href="https://twitter.com/toshimaru_e/status/1273437750499270659?ref_src=twsrc%5Etfw">June 18, 2020</a></blockquote>

<p>ただ go modules のアップデートに関しては、アップデート時に <code class="language-plaintext highlighter-rouge">go mod tidy</code> を実行してくれないという問題がありました。</p>

<blockquote class="twitter-tweet"><p lang="ja" dir="ltr">renovate ならオプションでやってくれるみたいなのでGoプロジェクトはこっちに乗り換えるかー<a href="https://t.co/qVbkb5UXlA">https://t.co/qVbkb5UXlA</a></p>&mdash; toshimaru (@toshimaru_e) <a href="https://twitter.com/toshimaru_e/status/1219800597982932992?ref_src=twsrc%5Etfw">January 22, 2020</a></blockquote>

<p>代替として、<a href="https://github.com/renovatebot/renovate">Renovate</a>という <code class="language-plaintext highlighter-rouge">go mod tidy</code> してくれるアップデーターを使っていました。</p>

<p>しかし、この度 Dependabot が <code class="language-plaintext highlighter-rouge">go mod tidy</code> も実行してくれるようになっていました。</p>

<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Dependabot: `go mod tidy` and `vendor` support <a href="https://t.co/x9Wwj0yuMG">https://t.co/x9Wwj0yuMG</a></p>&mdash; GitHub Changelog (@GHchangelog) <a href="https://twitter.com/GHchangelog/status/1318223496569290752?ref_src=twsrc%5Etfw">October 19, 2020</a></blockquote>

<h2 id="dependabot-go-modules設定">Dependabot Go Modules設定</h2>

<p><code class="language-plaintext highlighter-rouge">.github/dependabot.yml</code> ファイルを作って、下記のように記述すればOK。</p>

<div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># .github/dependabot.yml</span>
<span class="na">version</span><span class="pi">:</span> <span class="m">2</span>
<span class="na">updates</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">package-ecosystem</span><span class="pi">:</span> <span class="s2">"</span><span class="s">gomod"</span>
    <span class="na">directory</span><span class="pi">:</span> <span class="s2">"</span><span class="s">/"</span> <span class="c1"># Location of package manifests</span>
    <span class="na">schedule</span><span class="pi">:</span>
      <span class="na">interval</span><span class="pi">:</span> <span class="s2">"</span><span class="s">weekly"</span>
</code></pre></div></div>

<p>下記のPRの通り、きちんと <code class="language-plaintext highlighter-rouge">go mod tidy</code> をやってくれています。</p>

<p><a href="https://github.com/toshimaru/nyan/pull/104">github.com/toshimaru/nyan/pull/104</a></p>

<h2 id="参考">参考</h2>

<ul>
  <li><a href="https://github.blog/changelog/2020-10-19-dependabot-go-mod-tidy-and-vendor-support/">Dependabot: <code class="language-plaintext highlighter-rouge">go mod tidy</code> and <code class="language-plaintext highlighter-rouge">vendor</code> support - GitHub Changelog</a></li>
  <li><a href="https://github.com/golang/go/wiki/Modules">Modules · golang/go Wiki</a></li>
</ul>]]></content><author><name>Toshimaru</name></author><category term="go" /><summary type="html"><![CDATA[Dependabot が GitHub の公式機能の一部として利用可能になりました。ただ go modules のアップデートに関しては、アップデート時に go mod tidy を実行してくれないという問題がありました。代替として、Renovateという go mod tidy してくれるアップデーターを使っていました。しかし、この度 Dependabot が go mod tidy も実行してくれるようになっていました。]]></summary></entry><entry><title type="html">複数のGoroutineをWaitGroup（ErrGroup）で制御する</title><link href="https://blog.toshimaru.net/goroutine-with-waitgroup/" rel="alternate" type="text/html" title="複数のGoroutineをWaitGroup（ErrGroup）で制御する" /><published>2019-12-05T00:00:00+09:00</published><updated>2019-12-07T00:00:00+09:00</updated><id>https://blog.toshimaru.net/goroutine-with-waitgroup</id><content type="html" xml:base="https://blog.toshimaru.net/goroutine-with-waitgroup/"><![CDATA[<div class="info">
  <h5>追記</h5>
  <p>errgroup について追記しました。</p>
</div>

<p>この記事は<a href="https://qiita.com/advent-calendar/2019/go7">Go7 Advent Calendar 2019</a>五日目の記事です。</p>

<h2 id="やりたいこと">やりたいこと</h2>

<p>下記のように直列で動作し実行時間の長いGoのプログラムを、並行処理に変えて処理を効率化させます。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"time"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">2</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span> <span class="c">// 長い処理</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"End:"</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上述のプログラムを実行した場合、実行時間は約3分30秒となります。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>go run original.go
<span class="go">End: 0
End: 1
End: 2
...(snip)...
End: 97
End: 98
End: 99
</span></code></pre></div></div>

<p>これを並行に行うことで劇的な改善を目指します。</p>

<h2 id="goroutine-を使う">Goroutine を使う</h2>

<p>Goの並行処理といえば Goroutine。こいつを使うには処理を関数化して <code class="language-plaintext highlighter-rouge">go</code> というキーワードを付けるだけです。</p>

<p>下記のように変更します。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// original2.go</span>
<span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"time"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">go</span> <span class="k">func</span><span class="p">(</span><span class="n">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">2</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span> <span class="c">// 長い処理</span>
			<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"End:"</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
		<span class="p">}(</span><span class="n">i</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>実行してみましょう。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>go run original2.go
</code></pre></div></div>

<p>しかし、何も出力されません！　どうしてでしょうか？</p>

<h2 id="goroutine--channel-を使う">Goroutine + Channel を使う</h2>

<p>考えてみるとそれはそうで、Goroutine と呼ばれる軽量スレッドに処理を切り分けたものの、その処理の実行中にプログラム自体が終了してしまったからです。Goroutine の処理が完了するまで何らかの仕組みで「待つ」必要があります。</p>

<p>ここで使えるのが Channel です。Channel はデータの送受信ができる<a href="https://ja.wikipedia.org/wiki/%E3%83%91%E3%82%A4%E3%83%97_(%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF)">パイプ</a>のようなもので、主に Goroutine とのデータのやり取りで使われます。</p>

<p>Channel を使って Goroutine からのデータを受信するようにコードを書き換えてみましょう。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// channel.go</span>
<span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"time"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>

	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">go</span> <span class="k">func</span><span class="p">(</span><span class="n">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">2</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span> <span class="c">// 長い処理</span>
			<span class="n">ch</span> <span class="o">&lt;-</span> <span class="n">i</span>
		<span class="p">}(</span><span class="n">i</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"End:"</span><span class="p">,</span> <span class="o">&lt;-</span><span class="n">ch</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">int</code> 型の Channel を <code class="language-plaintext highlighter-rouge">make</code> する</li>
  <li>ループ内の Goroutine の中で↑で作成した Channel に値、<code class="language-plaintext highlighter-rouge">i</code> を送信</li>
  <li>2回目のループ内で Channel の値を受信して、Printする</li>
</ul>

<p>実行すると下記の通り、Goroutine から受信される値の順番はバラバラで出力されました。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ go run channel.go
End: 95
End: 98
End: 5
...snip...
End: 55
End: 30
End: 99
</code></pre></div></div>

<p>実行時間も2.6秒程で完了しました。最初の3分30秒という実行時間に比べて劇的な改善と言えるでしょう。</p>

<h2 id="goroutine--waitgroup-を使う">Goroutine + WaitGroup を使う</h2>

<p>しかし Channel を使うよりももっと良い書き方があるんです！ それが <code class="language-plaintext highlighter-rouge">sync.WaitGroup</code> です。</p>

<p><code class="language-plaintext highlighter-rouge">sync.WaitGroup</code> は複数の Goroutine の実行を待ってくれます。今回のプログラムの場合、下記のように書くことができます。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// waitgroup.go</span>
<span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"sync"</span>
	<span class="s">"time"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">wg</span> <span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span>

	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">wg</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="k">func</span><span class="p">(</span><span class="n">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">2</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span> <span class="c">// 長い処理</span>
			<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"End:"</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
			<span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span>
		<span class="p">}(</span><span class="n">i</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="n">wg</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">sync.WaitGroup</code> を宣言</li>
  <li>ループ内の Goroutine の処理の手前で <code class="language-plaintext highlighter-rouge">Add(1)</code> してグループをインクリメントする</li>
  <li>Goroutine 内の最後で <code class="language-plaintext highlighter-rouge">Done()</code> して Goroutine の処理が終わったことを <code class="language-plaintext highlighter-rouge">WaitGroup</code> に教えてあげる</li>
  <li>ループ終了後に、<code class="language-plaintext highlighter-rouge">Wait()</code> して <code class="language-plaintext highlighter-rouge">sync.WaitGroup</code> の <code class="language-plaintext highlighter-rouge">Done</code> を待つ</li>
</ul>

<p>実行すると下記の出力を得ることができます。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>go run waitgroup.go
<span class="go">End: 86
End: 5
End: 16
...(snip)...
End: 66
End: 85
End: 70
</span></code></pre></div></div>

<p>実行時間は2.2秒程で完了しました。Channel を使った場合よりも速く処理が完了したのは、Channel を使ったデータの送受信のオーバーヘッドを削れたことが大きいと考えられます。</p>

<h2 id="goroutine--errgroup-を使う">Goroutine + errgroup を使う</h2>

<p>Goroutine の処理内でエラーが発生する可能性があり、それをハンドリングしたいという場合はどうすればよいでしょうか？</p>

<p>そんなときに使えるのが<a href="https://godoc.org/golang.org/x/sync/errgroup">errgroup</a>です。errgroup を使ったコードを下記に示します。</p>

<p>※下記のコードサンプル内では <code class="language-plaintext highlighter-rouge">i</code> が90より大きい場合にエラーが発生するとしています。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// errgroup.go</span>
<span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"log"</span>
	<span class="s">"time"</span>

	<span class="s">"golang.org/x/sync/errgroup"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">eg</span> <span class="n">errgroup</span><span class="o">.</span><span class="n">Group</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">:=</span> <span class="n">i</span>
		<span class="n">eg</span><span class="o">.</span><span class="n">Go</span><span class="p">(</span><span class="k">func</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
			<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">2</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span> <span class="c">// 長い処理</span>
			<span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="m">90</span> <span class="p">{</span>
				<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Error:"</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Errorf</span><span class="p">(</span><span class="s">"Error occurred: %d"</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"End:"</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
			<span class="k">return</span> <span class="no">nil</span>
		<span class="p">})</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">eg</span><span class="o">.</span><span class="n">Wait</span><span class="p">();</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="n">log</span><span class="o">.</span><span class="n">Fatal</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">golang.org/x/sync/errgroup</code> をimportして <code class="language-plaintext highlighter-rouge">errgroup.Group</code> を宣言</li>
  <li><code class="language-plaintext highlighter-rouge">eg.Go()</code> 内で Goroutine の処理を定義</li>
  <li><code class="language-plaintext highlighter-rouge">eg.Wait()</code> して <code class="language-plaintext highlighter-rouge">eg.Go()</code> で実行した Goroutine を待つ</li>
  <li><code class="language-plaintext highlighter-rouge">eg.Go()</code> の処理でエラーがあれば、一番最初のエラーを <code class="language-plaintext highlighter-rouge">eg.Wait()</code> は返す</li>
</ul>

<p>実行すると下記の出力を得ることができます。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>go run errgroup.go
<span class="go">End: 86
End: 3
End: 1
End: 2
End: 11
Error: 96
End: 0
...(snip)...
Error: 93
End: 53
End: 84
End: 88
End: 74
2019/12/07 15:24:15 Error occurred: 96
exit status 1
</span></code></pre></div></div>

<p>全ての Goroutine を実行して最初に出会ったエラー、 <code class="language-plaintext highlighter-rouge">Error: 96</code> が <code class="language-plaintext highlighter-rouge">Error occurred: 96</code> として処理の最後で出力されていることがわかります。</p>

<h2 id="goroutine--errgroup--context-を使う">Goroutine + errgroup + context を使う</h2>

<p>もう少し踏み込んで高度なエラー処理をしてみましょう。エラーが発生したときに後続の Goroutine をキャンセルしたいという場合はどうしたらよいでしょうか？</p>

<p>これは <code class="language-plaintext highlighter-rouge">errgroup</code> に加えて、<a href="https://golang.org/pkg/context/">context</a>を組み合わせて使えば実現できます。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// errgroup_cancel.go</span>
<span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"context"</span>
	<span class="s">"fmt"</span>
	<span class="s">"log"</span>
	<span class="s">"time"</span>

	<span class="s">"golang.org/x/sync/errgroup"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">eg</span><span class="p">,</span> <span class="n">ctx</span> <span class="o">:=</span> <span class="n">errgroup</span><span class="o">.</span><span class="n">WithContext</span><span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">Background</span><span class="p">())</span>

	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">:=</span> <span class="n">i</span>
		<span class="n">eg</span><span class="o">.</span><span class="n">Go</span><span class="p">(</span><span class="k">func</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
			<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">2</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span> <span class="c">// 長い処理</span>

			<span class="k">select</span> <span class="p">{</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="n">ctx</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span><span class="o">:</span>
				<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Canceled:"</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
				<span class="k">return</span> <span class="no">nil</span>
			<span class="k">default</span><span class="o">:</span>
				<span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="m">90</span> <span class="p">{</span>
					<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Error:"</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Errorf</span><span class="p">(</span><span class="s">"Error: %d"</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"End:"</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
				<span class="k">return</span> <span class="no">nil</span>
			<span class="p">}</span>
		<span class="p">})</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">eg</span><span class="o">.</span><span class="n">Wait</span><span class="p">();</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="n">log</span><span class="o">.</span><span class="n">Fatal</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">errgroup.WithContext()</code> を使って、<code class="language-plaintext highlighter-rouge">errgroup</code> と <code class="language-plaintext highlighter-rouge">context</code> を生成</li>
  <li><code class="language-plaintext highlighter-rouge">eg.Go()</code> 内でキャンセルされたときの処理を <code class="language-plaintext highlighter-rouge">case &lt;-ctx.Done():</code> 内に記述</li>
  <li>non-nil error が返されると context はキャンセルされ、後続の Goroutine がキャンセルされる</li>
</ul>

<p>これを実行すると下記のような出力となります。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>go run errgroup_cancel.go
<span class="go">End: 5
End: 6
End: 23
Error: 98
End: 7
End: 8
Cenceled: 2
Cenceled: 9
...(snip)...
Cenceled: 92
Cenceled: 53
2019/12/07 15:43:48 Error: 98
exit status 1
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Error: 98</code> が発生し、後続の Goroutine がキャンセルされていることがわかります。</p>

<h2 id="まとめ">まとめ</h2>

<ul>
  <li>複数の Goroutine を取り扱う場合、<code class="language-plaintext highlighter-rouge">sync.WaitGroup</code> を使って制御（<code class="language-plaintext highlighter-rouge">Add</code>, <code class="language-plaintext highlighter-rouge">Done</code>, <code class="language-plaintext highlighter-rouge">Wait</code>）すると良い</li>
  <li>複数の Goroutine をエラーハンドリングとともに取り扱う場合、 <code class="language-plaintext highlighter-rouge">errgroup</code> を使って制御（<code class="language-plaintext highlighter-rouge">Go</code>, <code class="language-plaintext highlighter-rouge">Wait</code>, <code class="language-plaintext highlighter-rouge">WithContext</code>）すると良い</li>
</ul>

<h2 id="参考情報">参考情報</h2>

<ul>
  <li><a href="https://godoc.org/golang.org/x/sync/errgroup">errgroup - GoDoc</a></li>
  <li><a href="https://golang.org/pkg/context/">context - The Go Programming Language</a></li>
  <li><a href="https://deeeet.com/writing/2016/10/12/errgroup/">sync.ErrGroupで複数のgoroutineを制御する | SOTA</a></li>
  <li><a href="http://dono.hatenablog.com/entry/2018/01/04/111204">[Golang] errgroup使用例 - xonoのブログ</a></li>
</ul>]]></content><author><name>Toshimaru</name></author><category term="go" /><summary type="html"><![CDATA[この記事はGo7 Advent Calendar 2019五日目の記事です。やりたいこととしては、下記のように直列で動作し実行時間の長いGoのプログラムを、並行処理に変えて処理を効率化させます。]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://blog.toshimaru.net/images/posts/goroutine-waitgroup.png" /><media:content medium="image" url="https://blog.toshimaru.net/images/posts/goroutine-waitgroup.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Syntax HighlightされるcatコマンドをGoで作った</title><link href="https://blog.toshimaru.net/go-nyan-cat/" rel="alternate" type="text/html" title="Syntax HighlightされるcatコマンドをGoで作った" /><published>2019-08-15T00:00:00+09:00</published><updated>2019-08-15T00:00:00+09:00</updated><id>https://blog.toshimaru.net/go-nyan-cat</id><content type="html" xml:base="https://blog.toshimaru.net/go-nyan-cat/"><![CDATA[<p>Goの習作としてSyntax Highlight可能な<code class="language-plaintext highlighter-rouge">cat</code>コマンドを作った。</p>

<blockquote class="twitter-tweet"><p lang="ja" dir="ltr">夏休みの工作で作ったやつ。Go 製の Syntax Highlight な cat コマンド. | toshimaru/nyan: Colored `cat` command. <a href="https://t.co/lu1CL4YdDi">https://t.co/lu1CL4YdDi</a></p>&mdash; toshimaru (@toshimaru_e) <a href="https://twitter.com/toshimaru_e/status/1161656766100230144?ref_src=twsrc%5Etfw">August 14, 2019</a></blockquote>

<h2 id="モチベーション">モチベーション</h2>

<p>全く同じコンセプトのツールとして<a href="https://github.com/jingweno/ccat">ccat</a>があるのだが、デフォルトのハイライト色が黒背景のターミナルだと見づらいという問題があった。</p>

<p>更に強力な<code class="language-plaintext highlighter-rouge">cat</code>コマンドとしてRust製の<a href="https://github.com/sharkdp/bat">bat</a>があるのだが、これを<code class="language-plaintext highlighter-rouge">ccat</code>とともに併用していて配色がとても美しい感じに仕上がっていたので「よし、じゃあGoで配色がいい感じのやつ作ってみるか」と思い立って作成開始したやつ。</p>

<p>ちなみに<code class="language-plaintext highlighter-rouge">ccat</code>との実装の違いでいうと、<code class="language-plaintext highlighter-rouge">ccat</code>はsynatax highlightに<a href="https://github.com/sourcegraph/syntaxhighlight">sourcegraph/syntaxhighlight</a>を使っていて、今回作った<code class="language-plaintext highlighter-rouge">nyan</code>は<a href="https://github.com/alecthomas/chroma">alecthomas/chroma</a>を使っている。</p>

<h2 id="使ったgoライブラリサービスなど">使ったGoライブラリ・サービスなど</h2>

<h3 id="goライブラリ">Goライブラリ</h3>

<ul>
  <li>パッケージ管理: <a href="https://blog.golang.org/using-go-modules">go modules</a></li>
  <li>CLIライブラリ: <a href="https://github.com/spf13/cobra">cobra</a></li>
  <li>Syntax Highlightライブラリ: <a href="https://github.com/alecthomas/chroma">chroma</a></li>
  <li>リリース管理: <a href="https://github.com/goreleaser/goreleaser">goreleaser</a>
    <ul>
      <li>homebrew tapへのリリースも自動でやってくれている: <a href="https://github.com/toshimaru/homebrew-nyan">homebrew-nyan</a></li>
    </ul>
  </li>
  <li>テストライブラリ: <a href="https://github.com/stretchr/testify">testify</a>/assert</li>
</ul>

<h3 id="サービス">サービス</h3>

<ul>
  <li>CI: <a href="https://travis-ci.com">TravisCI</a></li>
  <li>Code Coverage: <a href="https://codeclimate.com">Code Climate</a></li>
</ul>

<h2 id="今後の展望">今後の展望</h2>

<ul>
  <li>今回CIはTravisで動かしたけど先日リリースされた<a href="https://github.blog/2019-08-08-github-actions-now-supports-ci-cd/">GitHub Actons(v2)</a>が使えるようになったら乗り換えたい</li>
  <li>行番号表示などの機能拡張も今後やっていきたい</li>
</ul>

<h2 id="goでツール書いてみた感想">Goでツール書いてみた感想</h2>

<ul>
  <li>パッケージ管理の機能が言語としてサポートされたのは嬉しい（Go 1.11〜）</li>
  <li>プログラムのコンパイル、実行、テストなどすべてが早いので開発体験がとても良い</li>
  <li>普段はRubyを使うことが多いが、書き味の良さではGoはRubyに負けるかもだけど、Goは堅牢で高速なアプリケーションを書くのに良い</li>
  <li>Goコミュニティは日本でもとても活発だし、ライブラリのエコシステムも整っているのが素晴らしい</li>
</ul>]]></content><author><name>Toshimaru</name></author><category term="go" /><category term="oss" /><summary type="html"><![CDATA[Goの習作としてSyntax Highlight可能な`cat`コマンドを作った。モチベーション 全く同じコンセプトのツールとしてccatがあるのだが、デフォルトのハイライト色が黒背景のターミナルだと見づらいという問題があった。 更に強力なcatコマンドとしてRust製のbatがあるのだが、これをccatとともに併用していて配色がとても美しい感じに仕上がっていたので「よし、じゃあGoで配色がいい感じのやつ作ってみるか」と思い立って作成開始したやつ。 ちなみにccatとの実装の違いでいうと、ccatはsynatax highlightにsourcegraph/syntaxhighlightを使っていて、今回作ったnyanはalecthomas/chromaを使っている。]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://user-images.githubusercontent.com/803398/63024853-00b18b80-bee3-11e9-853a-eea7e790a575.png" /><media:content medium="image" url="https://user-images.githubusercontent.com/803398/63024853-00b18b80-bee3-11e9-853a-eea7e790a575.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Goの日付フォーマット 〜＜2006年1月2日＞の謎〜</title><link href="https://blog.toshimaru.net/go-time-format/" rel="alternate" type="text/html" title="Goの日付フォーマット 〜＜2006年1月2日＞の謎〜" /><published>2017-09-15T00:00:00+09:00</published><updated>2019-12-07T00:00:00+09:00</updated><id>https://blog.toshimaru.net/go-time-format</id><content type="html" xml:base="https://blog.toshimaru.net/go-time-format/"><![CDATA[<p>Goの現在時刻は <code class="language-plaintext highlighter-rouge">time.Now()</code> で取得することができるが、フォーマットされた現在日時はどのように取得すればよいのだろうか？</p>

<h2 id="今日の日付の取得">今日の日付の取得</h2>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"time"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c">// フォーマットなし現在時刻</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">())</span>
	<span class="c">// フォーマットあり現在時刻</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span><span class="o">.</span><span class="n">Format</span><span class="p">(</span><span class="s">"2006年01月02日"</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>

<p>これで今日の日付を取得することができる。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2009-11-10 23:00:00 +0000 UTC m=+0.000000001
2009年11月10日
</code></pre></div></div>

<h2 id="2006年1月2日の謎">2006年1月2日の謎</h2>

<p>しかしここで１つの疑問が残る。<code class="language-plaintext highlighter-rouge">Format()</code>の引数として与えられる <code class="language-plaintext highlighter-rouge">2006年01月02日</code> はどうして2006年1月2日なのだろうか？　2001年2月3日でもダメだし1234年5月6日でもダメだ。きっちり <strong>2006年1月2日</strong> でなければならない。</p>

<p>この理由については下記の記事で解説されている。</p>

<blockquote>
  <p>では一体この2006年1月2日という特別な日は、なんの日なのか？</p>

  <p>（…中略…）</p>

  <p>答えは単純だ。これはアメリカ式の時刻の順番なのだ。”1月2日午後3時4分5秒2006年”（つまり「自然な順番」で1, 2, 3, 4, 5, 6）を指しているのである。</p>
</blockquote>

<p>via. <a href="http://qiita.com/ruiu/items/5936b4c3bd6eb487c182">Goのtimeパッケージのリファレンスタイム（2006年1月2日）は何の日？ - Qiita</a></p>

<p>考えてみるとなんてことはない、<strong>アメリカ式の日時の表示順番でのインクリメンタルな自然数であった！</strong></p>

<h2 id="goの内部実装を覗いてみる">Goの内部実装を覗いてみる</h2>

<p>もう少し深く理解するために、Goでどのように実装されているかを覗いてみる。それぞれの<code class="language-plaintext highlighter-rouge">const</code>がどの数値とマッピングするかがコメントで示されている。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="p">(</span>
	<span class="n">_</span>                        <span class="o">=</span> <span class="no">iota</span>
	<span class="n">stdLongMonth</span>             <span class="o">=</span> <span class="no">iota</span> <span class="o">+</span> <span class="n">stdNeedDate</span>  <span class="c">// "January"</span>
	<span class="n">stdMonth</span>                                       <span class="c">// "Jan"</span>
	<span class="n">stdNumMonth</span>                                    <span class="c">// "1"</span>
	<span class="n">stdZeroMonth</span>                                   <span class="c">// "01"</span>
	<span class="n">stdLongWeekDay</span>                                 <span class="c">// "Monday"</span>
	<span class="n">stdWeekDay</span>                                     <span class="c">// "Mon"</span>
	<span class="n">stdDay</span>                                         <span class="c">// "2"</span>
	<span class="n">stdUnderDay</span>                                    <span class="c">// "_2"</span>
	<span class="n">stdZeroDay</span>                                     <span class="c">// "02"</span>
	<span class="n">stdHour</span>                  <span class="o">=</span> <span class="no">iota</span> <span class="o">+</span> <span class="n">stdNeedClock</span> <span class="c">// "15"</span>
	<span class="n">stdHour12</span>                                      <span class="c">// "3"</span>
	<span class="n">stdZeroHour12</span>                                  <span class="c">// "03"</span>
	<span class="n">stdMinute</span>                                      <span class="c">// "4"</span>
	<span class="n">stdZeroMinute</span>                                  <span class="c">// "04"</span>
	<span class="n">stdSecond</span>                                      <span class="c">// "5"</span>
	<span class="n">stdZeroSecond</span>                                  <span class="c">// "05"</span>
	<span class="n">stdLongYear</span>              <span class="o">=</span> <span class="no">iota</span> <span class="o">+</span> <span class="n">stdNeedDate</span>  <span class="c">// "2006"</span>
	<span class="n">stdYear</span>                                        <span class="c">// "06"</span>
	<span class="n">stdPM</span>                    <span class="o">=</span> <span class="no">iota</span> <span class="o">+</span> <span class="n">stdNeedClock</span> <span class="c">// "PM"</span>
	<span class="n">stdpm</span>                                          <span class="c">// "pm"</span>
	<span class="n">stdTZ</span>                    <span class="o">=</span> <span class="no">iota</span>                <span class="c">// "MST"</span>
	<span class="n">stdISO8601TZ</span>                                   <span class="c">// "Z0700"  // prints Z for UTC</span>
	<span class="n">stdISO8601SecondsTZ</span>                            <span class="c">// "Z070000"</span>
	<span class="n">stdISO8601ShortTZ</span>                              <span class="c">// "Z07"</span>
	<span class="n">stdISO8601ColonTZ</span>                              <span class="c">// "Z07:00" // prints Z for UTC</span>
	<span class="n">stdISO8601ColonSecondsTZ</span>                       <span class="c">// "Z07:00:00"</span>
	<span class="n">stdNumTZ</span>                                       <span class="c">// "-0700"  // always numeric</span>
	<span class="n">stdNumSecondsTz</span>                                <span class="c">// "-070000"</span>
	<span class="n">stdNumShortTZ</span>                                  <span class="c">// "-07"    // always numeric</span>
	<span class="n">stdNumColonTZ</span>                                  <span class="c">// "-07:00" // always numeric</span>
	<span class="n">stdNumColonSecondsTZ</span>                           <span class="c">// "-07:00:00"</span>
	<span class="n">stdFracSecond0</span>                                 <span class="c">// ".0", ".00", ... , trailing zeros included</span>
	<span class="n">stdFracSecond9</span>                                 <span class="c">// ".9", ".99", ..., trailing zeros omitted</span>

	<span class="n">stdNeedDate</span>  <span class="o">=</span> <span class="m">1</span> <span class="o">&lt;&lt;</span> <span class="m">8</span>             <span class="c">// need month, day, year</span>
	<span class="n">stdNeedClock</span> <span class="o">=</span> <span class="m">2</span> <span class="o">&lt;&lt;</span> <span class="m">8</span>             <span class="c">// need hour, minute, second</span>
	<span class="n">stdArgShift</span>  <span class="o">=</span> <span class="m">16</span>                 <span class="c">// extra argument in high bits, above low stdArgShift</span>
	<span class="n">stdMask</span>      <span class="o">=</span> <span class="m">1</span><span class="o">&lt;&lt;</span><span class="n">stdArgShift</span> <span class="o">-</span> <span class="m">1</span> <span class="c">// mask out argument</span>
<span class="p">)</span>
</code></pre></div></div>

<p>via. <a href="https://github.com/golang/go/blob/master/src/time/format.go">go/format.go at master · golang/go</a></p>

<p>この実装をみると <code class="language-plaintext highlighter-rouge">2006-01-02</code> は <code class="language-plaintext highlighter-rouge">{stdLongYear}-{stdZeroMonth}-{stdZeroDay}</code> であることがわかる。</p>

<h2 id="goの標準日付フォーマット">Goの標準日付フォーマット</h2>

<p>RFCなどの標準的な時刻フォーマットは、Goが標準で用意してくれている。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="p">(</span>
	<span class="n">ANSIC</span>       <span class="o">=</span> <span class="s">"Mon Jan _2 15:04:05 2006"</span>
	<span class="n">UnixDate</span>    <span class="o">=</span> <span class="s">"Mon Jan _2 15:04:05 MST 2006"</span>
	<span class="n">RubyDate</span>    <span class="o">=</span> <span class="s">"Mon Jan 02 15:04:05 -0700 2006"</span>
	<span class="n">RFC822</span>      <span class="o">=</span> <span class="s">"02 Jan 06 15:04 MST"</span>
	<span class="n">RFC822Z</span>     <span class="o">=</span> <span class="s">"02 Jan 06 15:04 -0700"</span> <span class="c">// RFC822 with numeric zone</span>
	<span class="n">RFC850</span>      <span class="o">=</span> <span class="s">"Monday, 02-Jan-06 15:04:05 MST"</span>
	<span class="n">RFC1123</span>     <span class="o">=</span> <span class="s">"Mon, 02 Jan 2006 15:04:05 MST"</span>
	<span class="n">RFC1123Z</span>    <span class="o">=</span> <span class="s">"Mon, 02 Jan 2006 15:04:05 -0700"</span> <span class="c">// RFC1123 with numeric zone</span>
	<span class="n">RFC3339</span>     <span class="o">=</span> <span class="s">"2006-01-02T15:04:05Z07:00"</span>
	<span class="n">RFC3339Nano</span> <span class="o">=</span> <span class="s">"2006-01-02T15:04:05.999999999Z07:00"</span>
	<span class="n">Kitchen</span>     <span class="o">=</span> <span class="s">"3:04PM"</span>
	<span class="c">// Handy time stamps.</span>
	<span class="n">Stamp</span>      <span class="o">=</span> <span class="s">"Jan _2 15:04:05"</span>
	<span class="n">StampMilli</span> <span class="o">=</span> <span class="s">"Jan _2 15:04:05.000"</span>
	<span class="n">StampMicro</span> <span class="o">=</span> <span class="s">"Jan _2 15:04:05.000000"</span>
	<span class="n">StampNano</span>  <span class="o">=</span> <span class="s">"Jan _2 15:04:05.000000000"</span>
<span class="p">)</span>
</code></pre></div></div>

<p>これを使って下記のように書くことができる。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"time"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span><span class="o">.</span><span class="n">Format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">RFC822Z</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>

<p>RFC822Z の形式で下記のように出力される。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>10 Nov 09 23:00 +0000
</code></pre></div></div>]]></content><author><name>Toshimaru</name></author><category term="go" /><summary type="html"><![CDATA[Goの現在時刻はtime.Now()で取得することができるがフォーマットされた現在日時はどのように取得すればよいだろうか？　Format()の引数として与えられる 2006年1月2日 はどうして2006年1月2日なのだろうか？　2001年2月3日でもダメだし1234年5月6日でもダメだ。きっちり 2006年1月2日 でなければならない。]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://blog.toshimaru.net/images/posts/go-time-format.png" /><media:content medium="image" url="https://blog.toshimaru.net/images/posts/go-time-format.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">RubyとGoとBashで並行処理のパフォーマンス比較をしてみた</title><link href="https://blog.toshimaru.net/ruby-vs-go/" rel="alternate" type="text/html" title="RubyとGoとBashで並行処理のパフォーマンス比較をしてみた" /><published>2015-03-05T00:00:00+09:00</published><updated>2019-11-24T00:00:00+09:00</updated><id>https://blog.toshimaru.net/ruby-vs-go</id><content type="html" xml:base="https://blog.toshimaru.net/ruby-vs-go/"><![CDATA[<p>Rubyで書いたコードをGoで書き直したらどれくらい早くなるかを検証したくてやってみた。ついでにBashでもどうなるかも比較した。</p>

<p>画像ファイルをダウンロードするだけの単純な処理での比較。複雑な処理になるとまた結果は全然違ってくると思います。あしからず。</p>

<h2 id="比較する処理内容">比較する処理内容</h2>

<p>100個の画像をダウンロードするコードをサンプルにやってみた。</p>

<h2 id="rubyの場合">Rubyの場合</h2>

<p>Ruby 2.6 で検証。</p>

<h3 id="直列ダウンロード">直列ダウンロード</h3>

<p>まずは何も考えず順番に１つ１つダウンロードするRubyコード。</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># no_thread.rb</span>
<span class="nb">require</span> <span class="s1">'open-uri'</span>

<span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">).</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
  <span class="nb">open</span><span class="p">(</span><span class="s2">"./images/</span><span class="si">#{</span><span class="n">i</span><span class="si">}</span><span class="s2">.png"</span><span class="p">,</span> <span class="s1">'wb'</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">f</span><span class="o">|</span>
    <span class="n">f</span><span class="p">.</span><span class="nf">write</span> <span class="nb">open</span><span class="p">(</span><span class="s2">"https://dummyimage.com/600x400"</span><span class="p">).</span><span class="nf">read</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span><span class="nb">time </span>ruby no_thread.rb
<span class="go">ruby no_thread.rb  1.85s user 0.28s system 1% cpu 2:05.11 total
</span></code></pre></div></div>

<ul>
  <li>実行時間: 約2分。遅い</li>
  <li>CPU: 1％。CPUはほとんど使い切れていないことがわかる</li>
</ul>

<h3 id="threadで並行ダウンロード">Threadで並行ダウンロード</h3>

<p>Threadを使って並行に処理してみる。</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># thread.rb</span>
<span class="nb">require</span> <span class="s1">'open-uri'</span>

<span class="n">threads</span> <span class="o">=</span> <span class="p">[]</span>
<span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">).</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
  <span class="n">threads</span> <span class="o">&lt;&lt;</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
    <span class="nb">open</span><span class="p">(</span><span class="s2">"./images/</span><span class="si">#{</span><span class="n">i</span><span class="si">}</span><span class="s2">.png"</span><span class="p">,</span> <span class="s1">'wb'</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">f</span><span class="o">|</span>
      <span class="n">f</span><span class="p">.</span><span class="nf">write</span> <span class="nb">open</span><span class="p">(</span><span class="s2">"https://dummyimage.com/600x400"</span><span class="p">).</span><span class="nf">read</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="n">threads</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:join</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span><span class="nb">time </span>ruby thread.rb
<span class="go">ruby thread.rb  1.64s user 0.28s system 71% cpu 2.670 total
</span></code></pre></div></div>

<ul>
  <li>実行時間: 2.6秒。劇的な改善</li>
  <li>CPU: 70％。うまくCPUも使えている</li>
</ul>

<h2 id="goの場合">Goの場合</h2>

<p>Goで書き直してみる。Goのバージョンは1.13を使用。</p>

<p><a href="http://qiita.com/keisukeP/items/f4d680eb9e8f93263fa9">こちらのコード</a>を参考に書いてみた。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// go.go</span>
<span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"io"</span>
	<span class="s">"net/http"</span>
	<span class="s">"os"</span>
	<span class="s">"sync"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">wg</span> <span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span>
	<span class="k">var</span> <span class="n">url</span> <span class="kt">string</span> <span class="o">=</span> <span class="s">"https://dummyimage.com/600x400"</span>

	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">file</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">os</span><span class="o">.</span><span class="n">Create</span><span class="p">(</span><span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"images/%d.png"</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
		<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="nb">panic</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="n">wg</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="n">response</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">http</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
				<span class="nb">panic</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">defer</span> <span class="n">response</span><span class="o">.</span><span class="n">Body</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span>
			<span class="k">defer</span> <span class="n">file</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span>
			<span class="n">io</span><span class="o">.</span><span class="n">Copy</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">response</span><span class="o">.</span><span class="n">Body</span><span class="p">)</span>
			<span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span>
		<span class="p">}()</span>
	<span class="p">}</span>

	<span class="n">wg</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="go-runで実行">Go runで実行</h3>

<p>コンパイルせずに<code class="language-plaintext highlighter-rouge">go run</code>で実行してみる。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span><span class="nb">time </span>go run go.go
<span class="go">go run go.go  0.79s user 0.37s system 25% cpu 4.532 total
</span></code></pre></div></div>

<ul>
  <li>実行時間: 約4.5秒</li>
  <li>CPU: 25％</li>
</ul>

<h3 id="build済みバイナリで実行">build済みバイナリで実行</h3>

<p>buildして実行する。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>go build go.go
<span class="gp">$</span><span class="w"> </span><span class="nb">time</span> ./go
<span class="go">./go  0.23s user 0.12s system 11% cpu 3.111 total
</span></code></pre></div></div>

<ul>
  <li>実行時間: 約3秒。RubyのThreadコードより少し遅かった</li>
  <li>CPU: 約10％。速度のわりにCPU消費が著しく低い！</li>
</ul>

<h2 id="bashの場合">Bashの場合</h2>

<p>Bash（シェルスクリプト）の場合も試してみる。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># bash.bash</span>
<span class="k">for </span>i <span class="k">in</span> <span class="sb">`</span><span class="nb">seq </span>1 100<span class="sb">`</span><span class="p">;</span> <span class="k">do
  </span>wget <span class="nt">--background</span> <span class="nt">--quiet</span> <span class="s2">"https://dummyimage.com/600x400"</span> <span class="nt">-O</span> images/<span class="nv">$i</span>.png <span class="o">&gt;</span> /dev/null
<span class="k">done</span>
</code></pre></div></div>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span><span class="nb">time</span> ./bash.bash
<span class="go">./bash.bash  0.25s user 0.30s system 43% cpu 1.241 total
</span></code></pre></div></div>

<ul>
  <li>実行時間: 約1.2秒。速い！</li>
  <li>CPU: 約40%</li>
</ul>

<h2 id="まとめ">まとめ</h2>

<p>単純な並行ダウンロードという処理において、実行速度だけでいうとRubyもThreadを使えばGoと同じ速度は出せるということがわかった。</p>

<p>一方でCPUコストに関してはビルド済みのGoバイナリのほうが圧倒的低く済むということが判明した。つまり複雑な計算処理においてはGoがRubyよりずっとアドバンテージがあるであろうことがわかった。</p>

<p>今回は単純な処理なのでRubyとGoの間で処理速度に大きな差は生まれなかったものの、比較するロジックが複雑化すればするほどRubyはGoに負けそうな予感がした。</p>]]></content><author><name>Toshimaru</name></author><category term="ruby" /><category term="go" /><category term="bash" /><summary type="html"><![CDATA[Rubyで書いたコードをGoで書き直したらどれくらい早くなるかを検証したくてやってみた。ついでにBashでもどうなるかも比較した。]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://blog.toshimaru.net/images/posts/ruby-vs-go.jpg" /><media:content medium="image" url="https://blog.toshimaru.net/images/posts/ruby-vs-go.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>