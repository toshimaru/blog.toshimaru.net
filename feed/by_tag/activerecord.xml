<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://blog.toshimaru.net/feed/by_tag/activerecord.xml" rel="self" type="application/atom+xml" /><link href="https://blog.toshimaru.net/" rel="alternate" type="text/html" /><updated>2022-05-23T01:30:20+09:00</updated><id>https://blog.toshimaru.net/feed/by_tag/activerecord.xml</id><title type="html">Hack Your Design!</title><subtitle>toshimaruの技術系なブログ</subtitle><author><name>Toshimaru</name></author><entry><title type="html">銀座Rails#21で「Fat Modelの倒し方」を発表しました</title><link href="https://blog.toshimaru.net/how-to-deal-with-fat-model/" rel="alternate" type="text/html" title="銀座Rails#21で「Fat Modelの倒し方」を発表しました" /><published>2020-06-01T00:00:00+09:00</published><updated>2020-06-05T00:00:00+09:00</updated><id>https://blog.toshimaru.net/how-to-deal-with-fat-model</id><content type="html" xml:base="https://blog.toshimaru.net/how-to-deal-with-fat-model/"><![CDATA[<p><a href="https://ginza-rails.connpass.com/event/173610/">銀座Rails#21</a>で「Fat Modelの倒し方」と題して発表してきました。</p>

<h2 id="発表スライド">発表スライド</h2>

<script async="" class="speakerdeck-embed" data-id="fa367404507c4311aa3eeb087fc45a6e" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js"></script>

<h2 id="目次">目次</h2>

<ul id="markdown-toc">
  <li><a href="#発表スライド" id="markdown-toc-発表スライド">発表スライド</a></li>
  <li><a href="#目次" id="markdown-toc-目次">目次</a></li>
  <li><a href="#fat-rails-stage" id="markdown-toc-fat-rails-stage">Fat Rails Stage</a></li>
  <li><a href="#fat-model対処のための３つのアプローチ" id="markdown-toc-fat-model対処のための３つのアプローチ">Fat Model対処のための３つのアプローチ</a></li>
  <li><a href="#rails-modelの限界" id="markdown-toc-rails-modelの限界">Rails Modelの限界</a></li>
  <li><a href="#rails-modelはなぜ辛くなるのか" id="markdown-toc-rails-modelはなぜ辛くなるのか">Rails Modelはなぜ辛くなるのか？</a></li>
  <li><a href="#目指すべきゴール" id="markdown-toc-目指すべきゴール">目指すべきゴール</a></li>
  <li><a href="#rails-way" id="markdown-toc-rails-way">Rails Way</a>    <ul>
      <li><a href="#concerns" id="markdown-toc-concerns">Concerns</a></li>
      <li><a href="#sti" id="markdown-toc-sti">STI</a></li>
      <li><a href="#polymorphic-association" id="markdown-toc-polymorphic-association">Polymorphic Association</a></li>
      <li><a href="#accepts_nested_attributes_for" id="markdown-toc-accepts_nested_attributes_for">accepts_nested_attributes_for</a></li>
      <li><a href="#その他細かめのテクニック" id="markdown-toc-その他細かめのテクニック">その他細かめのテクニック</a></li>
      <li><a href="#rails-wayまとめ" id="markdown-toc-rails-wayまとめ">「Rails Way」まとめ</a></li>
    </ul>
  </li>
  <li><a href="#sub-rails-way" id="markdown-toc-sub-rails-way">Sub-Rails Way</a>    <ul>
      <li><a href="#view-model" id="markdown-toc-view-model">View Model</a></li>
      <li><a href="#権限管理認可" id="markdown-toc-権限管理認可">権限管理・認可</a></li>
      <li><a href="#interactor" id="markdown-toc-interactor">Interactor</a></li>
      <li><a href="#特定の課題の解決" id="markdown-toc-特定の課題の解決">特定の課題の解決</a></li>
      <li><a href="#それrailsでできるよ" id="markdown-toc-それrailsでできるよ">「それRailsでできるよ」</a></li>
      <li><a href="#それrubyでできるよ" id="markdown-toc-それrubyでできるよ">「それRubyでできるよ」</a></li>
      <li><a href="#saasに切り出す" id="markdown-toc-saasに切り出す">SaaSに切り出す</a></li>
      <li><a href="#sub-rails-wayまとめ" id="markdown-toc-sub-rails-wayまとめ">「Sub-Rails Way」まとめ</a></li>
    </ul>
  </li>
  <li><a href="#non-rails-way" id="markdown-toc-non-rails-way">Non-Rails Way</a>    <ul>
      <li><a href="#form-model" id="markdown-toc-form-model">Form Model</a></li>
      <li><a href="#poro" id="markdown-toc-poro">PORO</a></li>
      <li><a href="#service-class" id="markdown-toc-service-class">Service Class</a></li>
      <li><a href="#1-table-multiple-models" id="markdown-toc-1-table-multiple-models">1 Table Multiple Models</a></li>
      <li><a href="#non-rails-wayまとめ" id="markdown-toc-non-rails-wayまとめ">「Non-Rails Way」まとめ</a></li>
    </ul>
  </li>
  <li><a href="#全体のまとめ" id="markdown-toc-全体のまとめ">全体のまとめ</a></li>
  <li><a href="#参考資料" id="markdown-toc-参考資料">参考資料</a></li>
  <li><a href="#後編質問感想編" id="markdown-toc-後編質問感想編">後編（質問・感想編）</a></li>
</ul>

<h2 id="fat-rails-stage">Fat Rails Stage</h2>

<p>肥大化したRailsアプリケーション（Fat Rails Application）において最も辛いレイヤーはどこでしょうか？</p>

<ol>
  <li>Fat View</li>
  <li>Fat Controller</li>
  <li>Fat Model</li>
</ol>

<p>僕はFat Modelだと考えています。</p>

<p>下記は「RailsがどのようにFatになっていくか」段階を示した表です。</p>

<table>
  <thead>
    <tr>
      <th>Fat Stage</th>
      <th>Rails習熟度</th>
      <th>Fat Layer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>低</td>
      <td>Fat View</td>
    </tr>
    <tr>
      <td>2</td>
      <td>中</td>
      <td>Fat Controller</td>
    </tr>
    <tr>
      <td>3</td>
      <td>高</td>
      <td>Fat Model<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></td>
    </tr>
  </tbody>
</table>

<p>まずはFatステージ1。Railsというものを全然知らない超初心者が陥るステージです。ビューに何でもかんでもロジックを書いちゃう。その結果がFat Viewです。</p>

<p>次にFatステージ2。ある程度Railsに慣れてきた開発者が陥るステージです。Modelへのロジック分離がうまくできず、Controllerにロジックが集中する。その結果はFat Controllerです。</p>

<p>最後がFatステージ3。Railsを習熟したエンジニアであればModelにロジックを寄せていくのが定石です。その結果出来上がるのはFat Modelです。</p>

<p>このように <strong>どんなにRailsに習熟してようと最終的にぶつかる壁がFat Model</strong> です。</p>

<h2 id="fat-model対処のための３つのアプローチ">Fat Model対処のための３つのアプローチ</h2>

<p>Fat Modelを倒すためのアプローチとして、僕は下記の3つに分けて整理すれば良いのではと考えました。</p>

<ol>
  <li>Rails Way</li>
  <li>Sub-Rails Way</li>
  <li>Non-Rails Way</li>
</ol>

<h2 id="rails-modelの限界">Rails Modelの限界</h2>

<p>なぜRailsアプリケーションのModel層は限界を迎えてしまうのでしょうか？</p>

<p>Railsの原始的な状態は、1つのModelに1つのControllerが結びついています。すなわち、<code class="language-plaintext highlighter-rouge">User</code>モデルがあれば<code class="language-plaintext highlighter-rouge">UsersController</code>があり、Controllerのそれぞれのアクションに<code class="language-plaintext highlighter-rouge">User</code>モデルが紐づくという形です。</p>

<p>しかし下図<sup id="fnref:a" role="doc-noteref"><a href="#fn:a" class="footnote" rel="footnote">2</a></sup>はそれが破綻した状態です。どうなっているかというと、複数のControllerからいろんなかたちで１つのモデルが触られる、そういう状態です。</p>

<p><img src="/images/posts/ginzarails-21/controllers-model.jpg" alt="inline" /></p>

<p>続いてのスライドです<sup id="fnref:b" role="doc-noteref"><a href="#fn:b" class="footnote" rel="footnote">3</a></sup>。</p>

<p><img src="https://speakerd.s3.amazonaws.com/presentations/ce30c3cf9433471283e24855f6bdd2b4/slide_42.jpg?12161035" alt="inline" /></p>

<p>ここのキーワードとしては <strong>ユースケース</strong>。いろんなユースケースを1つのModelで表現しなければならないという状況が辛いと言えます。</p>

<h2 id="rails-modelはなぜ辛くなるのか">Rails Modelはなぜ辛くなるのか？</h2>

<ul>
  <li>1つのModelが複数の異なるユースケースに密結合して実装されるとき
    <ul>
      <li>→ ある条件やcontextに紐付いたValidation/Callback処理</li>
    </ul>
  </li>
  <li>1つのフォームで複数のサブリソースが更新されるとき（フォームとModelが1対1で紐付かないとき）
    <ul>
      <li>→ 1つのModelを起点とした複数Modelを跨ぐトランザクション処理</li>
    </ul>
  </li>
</ul>

<p>上述の限界は、Rails ModelとDBのテーブルが一対一で紐づくRailsの世界観に起因する限界と言えます。</p>

<h2 id="目指すべきゴール">目指すべきゴール</h2>

<p>ではどうRailsの限界を乗り越えていけばいいでしょうか？</p>

<p>下記は横軸がコードベースのサイズ、縦軸がペイン（痛みの度合い）を描いたグラフです<sup id="fnref:c" role="doc-noteref"><a href="#fn:c" class="footnote" rel="footnote">4</a></sup>。</p>

<p><img src="/images/posts/ginzarails-21/growth.png" alt="inline" /></p>

<p>赤線はバニラRailsです。コードベースのサイズとともにペインが増大しています。</p>

<p>緑線はストラクチャードRails。コードベースが増大してもペインが増大しません。</p>

<p>僕の発表の言うところでは、赤線（バニラRails）がRails Way、緑線（ストラクチャードRails）がSub-Rails・Non-Rails Wayにあたります。</p>

<p><img src="/images/posts/ginzarails-21/growth2.png" alt="inline" /></p>

<p>ということで我々の基本的なゴールとしてはこの緑線、すなわち、 <strong>コードベースが大きくなってもペインが増大しないRailsコードベース</strong> を目指しましょう、ということになります。</p>

<h2 id="rails-way">Rails Way</h2>

<p>小学生の絵みたいで恐縮なんですが、Rails Wayを絵にするとこんなイメージです。</p>

<p><img src="/images/posts/ginzarails-21/rails-way.png" alt="fit" /></p>

<p>つまり <strong>Railsのレールに沿った開発アプローチ</strong> です。</p>

<h3 id="concerns">Concerns</h3>

<p>まずはConcerns。Model/Controllerの共通の関心事（Concern）をmoduleに切り出す手法です（代表例: DHH’s <code class="language-plaintext highlighter-rouge">Recording</code> Class<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">5</a></sup>）。</p>

<p><img src="/images/posts/ginzarails-21/concerns.png" alt="inline" /></p>

<p>注意すべきは、ConcernのRails公式ガイドはありません。強いて言うなら下記の記事でDHHがConcernを紹介しています。</p>

<p><a href="https://signalvnoise.com/posts/3372-put-chubby-models-on-a-diet-with-concerns">Put chubby models on a diet with concerns</a></p>

<p>Modelの持っている能力（ability = <code class="language-plaintext highlighter-rouge">-able</code> suffix）に着目してConcern moduleに切り出していくのが、Rails Wayっぽさがあると言えます。</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># app/models/concerns/concernable.rb</span>
<span class="k">module</span> <span class="nn">Concernable</span>
  <span class="kp">extend</span> <span class="no">ActiveSupport</span><span class="o">::</span><span class="no">Concern</span>

  <span class="o">...</span><span class="p">(</span><span class="n">your</span> <span class="n">concern</span> <span class="n">code</span><span class="p">)</span><span class="o">...</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="sti">STI</h3>

<p>RailsにおいてテーブルとModelは原則的に1対1で結びつきます。しかし、STIを使えば1つのテーブルで複数Model紐付けることができます。</p>

<p>下図は<code class="language-plaintext highlighter-rouge">players</code>という単一テーブルに複数のクラスが結びついている図です<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">6</a></sup>。</p>

<p><img src="/images/posts/ginzarails-21/sti.png" alt="inline" /></p>

<p>Railsのコード例です。 <code class="language-plaintext highlighter-rouge">companies</code> テーブルに紐づく <code class="language-plaintext highlighter-rouge">Firm</code>, <code class="language-plaintext highlighter-rouge">Client</code>モデルの例だと下記の通りです。</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># app/models/company.rb</span>
<span class="k">class</span> <span class="nc">Company</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
<span class="k">end</span>

<span class="c1"># app/models/firm.rb</span>
<span class="k">class</span> <span class="nc">Firm</span> <span class="o">&lt;</span> <span class="no">Company</span>
<span class="k">end</span>

<span class="c1"># app/models/client.rb</span>
<span class="k">class</span> <span class="nc">Client</span> <span class="o">&lt;</span> <span class="no">Company</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="polymorphic-association">Polymorphic Association</h3>

<p>1つのポリモーフィック関連付け定義で複数のテーブルを従属させることができるのがポリモーフィック関連です。</p>

<p><img src="/images/posts/ginzarails-21/polymorphic.png" alt="inline" /></p>

<p>上図の場合、通常のRails DB設計であれば <code class="language-plaintext highlighter-rouge">pictures</code>テーブルが<code class="language-plaintext highlighter-rouge">employee_id</code>, <code class="language-plaintext highlighter-rouge">product_id</code>を持っているべきですが、<code class="language-plaintext highlighter-rouge">imagable_id</code>という1つカラムで複数のテーブルを従属させることができています。</p>

<p>これをRailsのコードであらわすと下記の通りです。</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># app/models/picture.rb</span>
<span class="k">class</span> <span class="nc">Picture</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">belongs_to</span> <span class="ss">:imageable</span><span class="p">,</span> <span class="ss">polymorphic: </span><span class="kp">true</span>
<span class="k">end</span>

<span class="c1"># app/models/employee.rb</span>
<span class="k">class</span> <span class="nc">Employee</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">has_many</span> <span class="ss">:pictures</span><span class="p">,</span> <span class="ss">as: :imageable</span>
<span class="k">end</span>

<span class="c1"># app/models/product.rb</span>
<span class="k">class</span> <span class="nc">Product</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">has_many</span> <span class="ss">:pictures</span><span class="p">,</span> <span class="ss">as: :imageable</span>
<span class="k">end</span>
</code></pre></div></div>

<p>ただし注意点があります。ポリモーフィック関連は『SQLアンチパターン』6章でアンチパターンとして紹介されており、使用する際は気をつける必要があります。</p>

<p>詳しくは『SQLアンチパターン』を読んでいただければと思います。</p>

<h3 id="accepts_nested_attributes_for">accepts_nested_attributes_for</h3>

<p>ネストされたアトリビュートで関連リソースの作成・更新・削除を行うのが<code class="language-plaintext highlighter-rouge">accepts_nested_attributes_for</code>です。</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Member</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:posts</span>
  <span class="n">accepts_nested_attributes_for</span> <span class="ss">:posts</span>
<span class="k">end</span>

<span class="n">params</span> <span class="o">=</span> <span class="p">{</span> <span class="ss">member: </span><span class="p">{</span>
  <span class="ss">name: </span><span class="s1">'joe'</span><span class="p">,</span> <span class="ss">posts_attributes: </span><span class="p">[</span>
    <span class="p">{</span> <span class="ss">title: </span><span class="s1">'Kari, the awesome Ruby documentation browser!'</span> <span class="p">},</span>
    <span class="p">{</span> <span class="ss">title: </span><span class="s1">'The egalitarian assumption of the modern citizen'</span> <span class="p">},</span>
  <span class="p">]</span>
<span class="p">}}</span>
<span class="n">member</span> <span class="o">=</span> <span class="no">Member</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:member</span><span class="p">])</span>
</code></pre></div></div>

<p>ただしこの<code class="language-plaintext highlighter-rouge">accepts_nested_attributes_for</code>はDHH自らが「消したい」と発言しており<sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">7</a></sup>、積極的に使うのはやや躊躇われるかもしれません。</p>

<p><img src="/images/posts/ginzarails-21/dhh.png" alt="inline" /></p>

<h3 id="その他細かめのテクニック">その他細かめのテクニック</h3>

<ul>
  <li><strong>Serialize Attribute</strong>
    <ul>
      <li>json型カラムへのメタデータ保存に便利</li>
      <li>⚠️『SQLアンチパターン』5章 EAV</li>
    </ul>
  </li>
  <li><strong>Value Object</strong> (<code class="language-plaintext highlighter-rouge">compose_of</code>)
    <ul>
      <li>複数カラムをValueオブジェクトとして展開するときに便利</li>
    </ul>
  </li>
  <li><strong>Validation Class</strong>/<strong>Callback Class</strong>
    <ul>
      <li>クラスとして分離可能 → 分離することで複数モデルで再利用可能に</li>
    </ul>
  </li>
</ul>

<h3 id="rails-wayまとめ">「Rails Way」まとめ</h3>

<p>全体としては、Rails WayだけではFat Modelを倒す手段として手数が少なく物足りないと感じます。</p>

<p>アプリケーションサイズがFatになっている時点でそのRailsアプリケーションは中規模以上のサイズが見込まれますから、正直Rails WayだけでFat Modelを倒すのは無理だと思います。</p>

<p>❌ Concerns, Validation ClassなどFat ModelをDRYに記述する手段にはなるが、構造的にダイエットする手段にはなっていません。あくまでそれらは局所的なダイエットに留まっています。</p>

<p>❌ STI, PolymorphicなどはDB設計と密結合したソリューションで、完全なコードレベルの解決にはなっていません。また、アンチパターンとして紹介されているように、それ自体が技術負債になりえる構造的問題を孕んでいます。</p>

<h2 id="sub-rails-way">Sub-Rails Way</h2>

<p>Sub-Rails Wayはレールを補強・拡張しつつレールに乗るスタイルです。</p>

<p><img src="/images/posts/ginzarails-21/sub-rails-way.png" alt="fit" /></p>

<p>レールを何を使って補強・拡張するのでしょうか？それは下記２つになります。</p>

<ol>
  <li>gem</li>
  <li>SaaS</li>
</ol>

<h3 id="view-model">View Model</h3>

<p>ModelにおけるView関連ロジックを <strong>View Model</strong> として切り出す手法です。</p>

<p>Development of Further PoEAAで<a href="https://martinfowler.com/eaaDev/PresentationModel.html">Presentation Model</a>という概念で紹介されているパターンにあたると考えています。ModelをDecoratorパターンっぽく拡張しているのでDecoratorとも呼ばれることが多いです<sup id="fnref:8" role="doc-noteref"><a href="#fn:8" class="footnote" rel="footnote">8</a></sup>。</p>

<p>このView Modelの良いところとしては、Fat Model の対処として機能するだけでなく、Fat View の対処としても機能する点です。</p>

<p>💎 gemの実装としては下記のようなものがあります。</p>

<ul>
  <li><a href="https://github.com/drapergem/draper">draper</a></li>
  <li><a href="https://github.com/amatsuda/active_decorator">active_decorator</a></li>
</ul>

<p>🔧 draperの場合、コードは下記のようになります（ArticleモデルのDecoratorクラス）。</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># app/decorators/article_decorator.rb</span>
<span class="k">class</span> <span class="nc">ArticleDecorator</span> <span class="o">&lt;</span> <span class="no">Draper</span><span class="o">::</span><span class="no">Decorator</span>
  <span class="n">delegate_all</span>

  <span class="k">def</span> <span class="nf">publication_status</span>
    <span class="k">if</span> <span class="n">published?</span>
      <span class="s2">"Published at </span><span class="si">#{</span><span class="n">published_at</span><span class="si">}</span><span class="s2">"</span>
    <span class="k">else</span>
      <span class="s2">"Unpublished"</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">published_at</span>
    <span class="n">object</span><span class="p">.</span><span class="nf">published_at</span><span class="p">.</span><span class="nf">strftime</span><span class="p">(</span><span class="s2">"%A, %B %e"</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="権限管理認可">権限管理・認可</h3>

<p>管理画面実装において逃げられない実装は認証とあわせて、権限管理・認可ではないでしょうか？</p>

<p>ResourceのCRUDでユーザーのアクセス制御するのが「Railsらしい」権限管理と考えています。</p>

<p>💎 gemの実装としては下記のようなものです。</p>

<ul>
  <li><a href="https://github.com/varvet/pundit">pundit</a></li>
  <li><a href="https://github.com/kyuden/banken">banken</a></li>
  <li><a href="https://github.com/CanCanCommunity/cancancan">cancancan</a></li>
</ul>

<p>🔧 punditの場合、コードは下記の通りです（Postモデルの認可クラス）。</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># app/policies/post_policy.rb</span>
<span class="k">class</span> <span class="nc">PostPolicy</span>
  <span class="nb">attr_reader</span> <span class="ss">:user</span><span class="p">,</span> <span class="ss">:post</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">user</span><span class="p">,</span> <span class="n">post</span><span class="p">)</span>
    <span class="vi">@user</span> <span class="o">=</span> <span class="n">user</span>
    <span class="vi">@post</span> <span class="o">=</span> <span class="n">post</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">update?</span>
    <span class="n">user</span><span class="p">.</span><span class="nf">admin?</span> <span class="n">or</span> <span class="n">not</span> <span class="n">post</span><span class="p">.</span><span class="nf">published?</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="interactor">Interactor</h3>

<p>InteractorはClean Architecture由来する概念です。</p>

<p>下記の図は見たことある方も多くいらっしゃるかもしれません。赤い部分がClean Architectureにおけるユースケース層になります。このユースケース層に Interactor が表現されています。</p>

<p><img src="https://blog.cleancoder.com/uncle-bob/images/2012-08-13-the-clean-architecture/CleanArchitecture.jpg" alt="inline" /></p>

<p>ユースケース層というアプローチはとても良いと思っています。なぜなら先程「1つのModelが複数の異なるユースケースに密結合して実装されるとき―」と言いましたが、そのユースケースをまさにInteractorとして表現できるからです。</p>

<p>個人的にClean ArchitectureとRailsは相性が良いと思っていて、このようにMVC+InteractorでClean Architectureのそれぞれの層と一致させることができるからです。</p>

<p><img src="/images/posts/ginzarails-21/Clean_Coder_Blog.png" alt="inline" /></p>

<p>💎 gemとしては下記があります。</p>

<ul>
  <li><a href="https://github.com/collectiveidea/interactor-rails">interactor-rails</a></li>
  <li>(not Rails) <a href="https://github.com/hanami">hanami</a>’s <a href="https://github.com/hanami/utils/blob/master/lib/hanami/interactor.rb">Interactor</a></li>
</ul>

<p>hanamiはRailsではありませんが、Clean Architectureに強く影響を受けたRuby製Webフレームワークです。hanamiには Interactor の仕組みが標準で実装されています。</p>

<p>🔧 interactor-railsの場合のコードは下記の通りです（ユーザーを認証するクラス）。</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># app/interactors/authenticate_user.rb</span>
<span class="k">class</span> <span class="nc">AuthenticateUser</span>
  <span class="kp">include</span> <span class="no">Interactor</span>

  <span class="k">def</span> <span class="nf">call</span>
    <span class="k">if</span> <span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">authenticate</span><span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="nf">email</span><span class="p">,</span> <span class="n">context</span><span class="p">.</span><span class="nf">password</span><span class="p">)</span>
      <span class="n">context</span><span class="p">.</span><span class="nf">user</span> <span class="o">=</span> <span class="n">user</span>
      <span class="n">context</span><span class="p">.</span><span class="nf">token</span> <span class="o">=</span> <span class="n">user</span><span class="p">.</span><span class="nf">secret_token</span>
    <span class="k">else</span>
      <span class="n">context</span><span class="p">.</span><span class="nf">fail!</span><span class="p">(</span><span class="ss">message: </span><span class="s2">"authenticate_user.failure"</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># Inside your controller,</span>
<span class="n">result</span> <span class="o">=</span> <span class="no">AuthenticateUser</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="n">session_params</span><span class="p">)</span>  
</code></pre></div></div>

<h3 id="特定の課題の解決">特定の課題の解決</h3>

<p>特定の課題を解決するgemとしては例えば下記のようなものがあります。</p>

<ul>
  <li><strong>論理削除</strong>
    <ul>
      <li>💎 gem: <a href="https://github.com/jhawthorn/discard">discard</a>, <a href="https://github.com/rubysherpas/paranoia">paranoia</a>, <a href="https://github.com/ActsAsParanoid/acts_as_paranoid">acts_as_paranoid</a></li>
      <li>⚠️ <a href="https://www.slideshare.net/t_wada/ronsakucasual">SQLアンチパターン 幻の第26章「とりあえず削除フラグ」</a></li>
    </ul>
  </li>
  <li><strong>要素のソート・並び替え</strong>
    <ul>
      <li>💎 gem: <a href="https://github.com/brendon/acts_as_list">acts_as_list</a>, <a href="https://github.com/mixonic/ranked-model">ranked-model</a></li>
    </ul>
  </li>
  <li><strong>State Machine</strong>
    <ul>
      <li>💎 gem: <a href="https://github.com/aasm/aasm">aasm</a>, <a href="https://github.com/amatsuda/stateful_enum">stateful_enum</a></li>
    </ul>
  </li>
  <li><strong>Tagging</strong>
    <ul>
      <li>💎 gem: <a href="https://github.com/mbleigh/acts-as-taggable-on">acts-as-taggable-on</a></li>
    </ul>
  </li>
  <li><strong>HashをActiveRecordっぽく操作</strong>
    <ul>
      <li>💎 gem: <a href="https://github.com/zilkey/active_hash">active_hash</a></li>
    </ul>
  </li>
</ul>

<p>解決したい課題に応じて導入していくのが良いと思います。</p>

<h3 id="それrailsでできるよ">「それRailsでできるよ」<sup id="fnref:10" role="doc-noteref"><a href="#fn:10" class="footnote" rel="footnote">9</a></sup></h3>

<p>逆にgemを使わずともRails標準で解決できるよって課題も多く存在します。例えば下記のような例です。</p>

<ul>
  <li>:gem: <a href="https://github.com/brainspec/enumerize">enumerize</a> (Emumerized Attributes)
    <ul>
      <li>Rails 4.1: ActiveRecord enum</li>
      <li>参考. <a href="https://api.rubyonrails.org/v5.2.3/classes/ActiveRecord/Enum.html">ActiveRecord::Enum</a></li>
    </ul>
  </li>
  <li>:gem: <a href="https://github.com/eagletmt/switch_point">switch_point</a> (Database R/W Split)
    <ul>
      <li>Rails 6: Multi-DB</li>
      <li>参考: <a href="https://railsguides.jp/active_record_multiple_databases.html">Active Record で複数のデータベース利用 - Railsガイド</a></li>
    </ul>
  </li>
  <li>:gem: <a href="https://github.com/zdennis/activerecord-import">activerecord-import</a> (Bulk Import)
    <ul>
      <li>Rails 6: <code class="language-plaintext highlighter-rouge">insert_all</code>, <code class="language-plaintext highlighter-rouge">upsert_all</code></li>
    </ul>
  </li>
  <li>:gem: <a href="https://github.com/carrierwaveuploader/carrierwave">carrierwave</a>, <a href="https://github.com/shrinerb/shrine">shrine</a> (File Uploader)
    <ul>
      <li>Rails 5.2: Active Storage</li>
      <li>参考: <a href="https://railsguides.jp/active_storage_overview.html">Active Storage の概要 - Railsガイド</a></li>
    </ul>
  </li>
  <li>:gem: <a href="https://github.com/norman/friendly_id">friendly_id</a>
    <ul>
      <li>ActiveRecord: <code class="language-plaintext highlighter-rouge">to_param</code></li>
      <li>参考: <a href="https://api.rubyonrails.org/classes/ActiveRecord/Integration.html#method-i-to_param">ActiveRecord::Integration</a></li>
    </ul>
  </li>
  <li>:gem: <a href="https://github.com/magnusvk/counter_culture">counter_culture</a>
    <ul>
      <li>ActiveRecord: <code class="language-plaintext highlighter-rouge">counter_cache</code></li>
      <li>参考: <a href="https://railsguides.jp/association_basics.html#belongs-to%E3%81%AE%E3%82%AA%E3%83%97%E3%82%B7%E3%83%A7%E3%83%B3-counter-cache">Active Record の関連付け</a></li>
    </ul>
  </li>
  <li>ID/Password認証
    <ul>
      <li>ActiveModel: <code class="language-plaintext highlighter-rouge">has_secure_password</code></li>
      <li>参考: <a href="https://api.rubyonrails.org/classes/ActiveModel/SecurePassword/ClassMethods.html">ActiveModel::SecurePassword::ClassMethods</a></li>
    </ul>
  </li>
  <li>:gem: <a href="https://github.com/rubyconfig/config">config</a> (YAML Config Management)
    <ul>
      <li>Rails Custom configuration:</li>
      <li><code class="language-plaintext highlighter-rouge">Rails::Application.config_for</code></li>
      <li><code class="language-plaintext highlighter-rouge">config.x</code></li>
      <li>参考: <a href="https://railsguides.jp/configuring.html#%E3%82%AB%E3%82%B9%E3%82%BF%E3%83%A0%E8%A8%AD%E5%AE%9A">Rails アプリケーションを設定する - Railsガイド</a></li>
    </ul>
  </li>
</ul>

<h3 id="それrubyでできるよ">「それRubyでできるよ」<sup id="fnref:10:1" role="doc-noteref"><a href="#fn:10" class="footnote" rel="footnote">9</a></sup></h3>

<p>gemを使わずともRubyでもできるよってケースもあります。</p>

<ul>
  <li>:gem: <a href="https://github.com/pry/pry">pry</a>
    <ul>
      <li>Ruby 2.4: <code class="language-plaintext highlighter-rouge">binding.irb</code></li>
      <li>Ruby 2.7: REPL Syntax Highlighting</li>
    </ul>
  </li>
</ul>

<h3 id="saasに切り出す">SaaSに切り出す</h3>

<p>処理をSaaSに切り出す、という意味では下記の例があります。</p>

<ul>
  <li><a href="https://auth0.com/jp/">Auth0</a>
    <ul>
      <li>ユーザー認証ロジックをAuth0に移譲</li>
      <li>認証にともなうMFA、パスワードリセット、セキュリティ対策などの面倒な実装をAuth0が肩代わり</li>
    </ul>
  </li>
  <li><a href="https://sentry.io/welcome/">Sentry</a>
    <ul>
      <li>エラー通知をSentryに移譲</li>
      <li>サービスにエラーをぽんぽん投げ込めばいい感じにエラーをアグリゲーション・可視化・各種通知してくれる</li>
    </ul>
  </li>
  <li><a href="https://newrelic.co.jp/">NewRelic</a>/<a href="https://www.datadoghq.com/ja/">Datadog</a>
    <ul>
      <li>APM (Application Performance Monitoring)を NewRelic/Datadog APMでやる</li>
      <li>自前で Elasticsearch + Kibana 環境を構築してもいいが、構築コスト・運用コストともに高くつく</li>
    </ul>
  </li>
</ul>

<h3 id="sub-rails-wayまとめ">「Sub-Rails Way」まとめ</h3>

<p>gem を使うことでFat Model対処法のバリエーションがぐっと広がります。独自実装でModelを太らせることをせず、使えるgemは積極的に利用していくとよいでしょう。</p>

<p>一方、gemを使わずともRails標準で解決できることも実は多くあるので見極めた上でgem導入しましょう。</p>

<p>また、選択肢はさほど多くないものの、最近はさまざまな便利SaaSが出ているので SaaSを使うのもFat Model対抗手段の１つとして検討してもよいでしょう。</p>

<h2 id="non-rails-way">Non-Rails Way</h2>

<p>Non-Railsはレールに乗らない別のレール、独自路線のことです。</p>

<p><img src="/images/posts/ginzarails-21/non-rails-way.png" alt="fit" /></p>

<p>つまり自らレールを作っていくスタイルです。</p>

<h3 id="form-model">Form Model</h3>

<p>Form Modelとは、<code class="language-plaintext highlighter-rouge">include ActiveModel</code>したRubyクラスのことです。</p>

<p>巷ではForm Objectと呼ばれることが多いですが、＜Formに特化したActiveModel＞という意味で、あえてForm Modelと本発表では呼んでいます。</p>

<p>フォームとForm Modelは一対一で紐付きます。こうすることで <strong>特定の＜Formのユースケース＞に対応したModel</strong> が作成可能になります。</p>

<p>💎 gemの実装としては下記のようなものがあります。</p>

<ul>
  <li><a href="https://github.com/trailblazer/reform">reform</a></li>
  <li><a href="https://github.com/dry-rb/">dry-rb</a>シリーズ（旧・<a href="https://github.com/solnic/virtus">virtus</a>）</li>
</ul>

<p>Form Modelの使い所としては下記のように整理できると思います。</p>

<table>
  <thead>
    <tr>
      <th>紐づく<br />テーブル数</th>
      <th>Form Modelのユースケース</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>問い合わせフォームなどテーブルを作るまでもないフォームで利用</td>
    </tr>
    <tr>
      <td>1</td>
      <td>-</td>
    </tr>
    <tr>
      <td>2以上</td>
      <td><code class="language-plaintext highlighter-rouge">accepts_nested_attributes_for</code>の代わりとして、複雑なフォームの組み立て時に利用</td>
    </tr>
  </tbody>
</table>

<p>テーブルとフォームが1対1で紐づく場合はRails Wayで解決させるのが素直な実装</p>

<p>その他の特定のユースケースに特化したForm Model実装としては、下記のようなものが考えられます。</p>

<ul>
  <li>SearchForm: 条件に基づく検索に特化したフォーム</li>
  <li>DownloadForm: CSVなどのダウンロードに特化したフォーム</li>
</ul>

<h3 id="poro">PORO</h3>

<p>POROとはPlain Old Ruby Objectの略です。元ネタはPoEAAのPOJO (Plain Old Java Object)です。</p>

<p>POROは、ActiveRecordの機能に依存しない純粋なRuby実装です。なので<code class="language-plaintext highlighter-rouge">include ActiveModel</code>しているRubyクラスは個人的にはPOROとは呼んでいません。</p>

<p>純粋なRuby実装なのである意味、 <strong>Ruby Way</strong> とも言うことができます。</p>

<p>POROの主な用途としてはModelの補助輪的な役割だと考えています。</p>

<p>例えば下記の例ではクラスメソッド<code class="language-plaintext highlighter-rouge">create!</code>呼び出し時に引数を受け取って<code class="language-plaintext highlighter-rouge">create!</code>インスタンスメソッド内でトランザクションを張って複数モデルの更新を行っています。</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">PostWithNotifications</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">create!</span><span class="p">(</span><span class="n">creator</span><span class="p">:,</span> <span class="n">body</span><span class="p">:)</span>
    <span class="n">new</span><span class="p">(</span><span class="ss">creator: </span><span class="n">creator</span><span class="p">,</span> <span class="ss">body: </span><span class="n">body</span><span class="p">).</span><span class="nf">create!</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">creator</span><span class="p">:,</span> <span class="n">body</span><span class="p">:)</span>
    <span class="vi">@creator</span> <span class="o">=</span> <span class="n">creator</span>
    <span class="vi">@body</span> <span class="o">=</span> <span class="n">body</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">create!</span>
    <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">.</span><span class="nf">transaction</span> <span class="k">do</span>
      <span class="n">create_post!</span>
      <span class="n">create_notifications!</span>
    <span class="k">end</span>    
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>このRubyクラスの場合、＜<code class="language-plaintext highlighter-rouge">Post</code>作成とともに<code class="language-plaintext highlighter-rouge">Notification</code>も作成する＞という複数モデル更新のユースケースをPOROに閉じ込めたということができるでしょう。</p>

<h3 id="service-class">Service Class</h3>

<p>続いてはサービスクラスです。</p>

<p>サービスクラスに関してはもしかしたら賛否両論あるかもしれません。サービスという概念がデカすぎる故に、人によって使い方・解釈が異なり、サービスクラスにまつわる巷のすれ違いを起こしている印象があります。</p>

<p>サービスクラスに関してはまずはサービスの定義問題があると思っています。つまり「あなたの言うServiceってなんですか？」という問題です。</p>

<p>一口にサービスといっても様々な文脈のサービスがあります。</p>

<table>
  <thead>
    <tr>
      <th>Architecture</th>
      <th>Service Name</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>PoEAA</strong></td>
      <td>Service Layer</td>
    </tr>
    <tr>
      <td><strong>DDD</strong></td>
      <td>Service Class</td>
    </tr>
    <tr>
      <td><strong>Onion Architecture</strong></td>
      <td>Application Service, Domain Service</td>
    </tr>
    <tr>
      <td><strong>Rails “Service”</strong> ?</td>
      <td>上記のどれでもない”Service”<br />上記を組み合わせた”Service”</td>
    </tr>
  </tbody>
</table>

<p>「どういう文脈のサービスか？」を明確にした上で議論しないとサービスクラスの定義・概念がボンヤリしてしまう印象です。なのでサービスクラスを導入する際は、サービスクラスの定義・使い方を明確にした上でチームに導入していくのが良いと思います。</p>

<p>個人的な見解にはなりますが、＜特定のユースケースの解決＞という意味においてはInteractorのほうが少なくともRailsにおいては筋が良いと考えています。</p>

<p>また、個人的に下手にサービスという巨大で強い概念を持ち込むより、POROという概念で雑にまとめたほうが好みだったりします。</p>

<h3 id="1-table-multiple-models">1 Table Multiple Models</h3>

<p>一つのテーブルに複数Modelを紐付けるアプローチです。</p>

<p>Rails WayだとSTIでのみこれは実現可能ですが、STIを使わずにがんばってアプリケーションコードで複数モデルを表現しちゃいましょうというやり方です。</p>

<p>コードにすると、例えば下記のようなコードになります。</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">User::AsSignUp</span> <span class="o">&lt;</span> <span class="no">User</span>
  <span class="n">validates</span> <span class="ss">:password</span><span class="p">,</span> <span class="o">...</span>
  <span class="n">after_create</span> <span class="ss">:send_welcome_email</span>

  <span class="kp">private</span>

  <span class="k">def</span> <span class="nf">send_welcome_email</span>
    <span class="o">...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>この例では＜<code class="language-plaintext highlighter-rouge">User</code>のサインアップ＞というユースケースにのみ特化したActiveRecordのModelを作成しています。</p>

<p>ただこの実装に関しては、1 Table 1 ModelというRailsのパラダイム（規約）を壊すことになってしまうので、いささか危険思想という印象があります。</p>

<p>ただ僕自身実際にプロダクションに導入して運用した経験はないので、もし実運用における成功例お持ちの方がいれば教えていただけると幸いです。</p>

<h3 id="non-rails-wayまとめ">「Non-Rails Way」まとめ</h3>

<p>4つの Non-Railsを紹介しました。</p>

<ol>
  <li>Form Model</li>
  <li>PORO</li>
  <li>Service Class</li>
  <li>1 Table Multiple Models</li>
</ol>

<p>これらをうまく導入できればFat Modelを倒す強力な武器となるのは間違いないでしょう。</p>

<p>どれをどう導入するかに関しては正解はないと思うのでチームにあった手法を選択すると良いと考えています。</p>

<p>といっても「どれを導入すればいいかわからん…」ってなると思うので個人的なおすすめアプローチを紹介すると、モデルを太らせてしまうような複雑なフォームに関してはForm Modelで表現するのがわかりやすいと思います。</p>

<p>何らかのユースケースに特化したクラスを作りたいのであれば、Sub-Railsのセクションで紹介したInteractorを使うのが個人的にはオススメです。</p>

<p>上記で足りないユースケースが出てきた場合、POROと総称してModelの補助輪となるようなRubyクラスを用意してあげると良いかと思います。</p>

<h2 id="全体のまとめ">全体のまとめ</h2>

<p>Fat Modelを倒すための3つのアプローチを紹介しました。</p>

<ol>
  <li><strong>Rails Way</strong>: Railsの規約に沿った開発アプローチ</li>
  <li><strong>Sub-Rails Way</strong>: Railsの規約をgemで補強・拡張するアプローチ</li>
  <li><strong>Non-Rails Way</strong>: Railsの規約から外れる独自実装アプローチ</li>
</ol>

<p>まずは、 <strong>Rails Way</strong> + <strong>Sub-Rails Way</strong> でFat Modelをダイエットできないか考えましょう。小規模なRailsアプリケーションであれば Rails Way + Sub-Rails Way で十分戦えると思います。</p>

<p>Rails Way + Sub-Rails Way だけで立ち行かなくなった場合に、必要に応じて適切な <strong>Non-Rails Way</strong> を取り入れていきましょう。</p>

<p><strong>Non-Rails Way</strong> はチーム毎に最適解があると思っています。チームで合意できる独自路線を選択・導入すればよいのではないでしょうか。</p>

<h2 id="参考資料">参考資料</h2>

<ul>
  <li>書籍
    <ul>
      <li><a href="https://amzn.to/2TO3ZTe">エンタープライズアプリケーションアーキテクチャパターン</a></li>
      <li><a href="https://amzn.to/2XfXKJT">Clean Architecture　達人に学ぶソフトウェアの構造と設計</a></li>
      <li><a href="https://amzn.to/3exaz8y">エリック・エヴァンスのドメイン駆動設計</a></li>
      <li><a href="https://leanpub.com/growing-rails">Growing Rails Applications in Practice</a> by Henning Koch and Thomas Eisenbarth</li>
    </ul>
  </li>
  <li>アーキテクチャにまつわる資料
    <ul>
      <li><a href="https://martinfowler.com/eaaDev/">Martin Fowler: Development of Further Patterns of Enterprise Application Architecture</a></li>
      <li><a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">Clean Coder Blog: The Clean Architecture</a></li>
      <li><a href="https://jeffreypalermo.com/2008/07/the-onion-architecture-part-1/">The Onion Architecture : part 1 | Programming with Palermo</a></li>
      <li><a href="https://guides.hanamirb.org/architecture/interactors/">Architecture: Interactors | Hanami Guides</a></li>
      <li><a href="https://qiita.com/yuku_t/items/961194a5443b618a4cac">中規模Web開発のためのMVC分割とレイヤアーキテクチャ - Qiita</a></li>
    </ul>
  </li>
  <li>Rails公式ドキュメント
    <ul>
      <li><a href="https://guides.rubyonrails.org/association_basics.html">Active Record Associations — Ruby on Rails Guides</a></li>
      <li><a href="https://guides.rubyonrails.org/active_model_basics.html">Active Model Basics — Ruby on Rails Guides</a></li>
      <li><a href="https://api.rubyonrails.org/classes/ActiveRecord/NestedAttributes/ClassMethods.html">accepts_nested_attributes_for</a></li>
      <li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Inheritance.html">ActiveRecord::Inheritance</a></li>
      <li><a href="https://api.rubyonrails.org/v6.0.2.1/classes/ActiveSupport/Concern.html">ActiveSupport::Concern</a></li>
    </ul>
  </li>
  <li>Form Model (Form Object)について
    <ul>
      <li><a href="https://tech.libinc.co.jp/entry/2019/04/05/113000">Railsで複数モデルを扱うフォームをすっきり書く（Formオブジェクト） - LiBz Tech Blog</a></li>
      <li><a href="https://moneyforward.com/engineers_blog/2018/12/15/formobject/">accepts_nested_attributes_forを使わず、複数の子レコードを保存する | Money Forward Engineers’ Blog</a></li>
      <li><a href="https://discourse.clean-rails.org/t/model-form-1-1/14">Model と画面上の form が1対1で一致しない場合、どのように実装するのが綺麗なのか？ - clean-rails.org</a></li>
    </ul>
  </li>
  <li>Service Class (Service Object) について
    <ul>
      <li><a href="https://techracho.bpsinc.jp/hachi8833/2017_10_16/46482">Railsで重要なパターンpart 1: Service Object（翻訳）｜TechRacho（テックラッチョ）〜エンジニアの「？」を「！」に〜｜BPS株式会社</a></li>
      <li><a href="https://qiita.com/joker1007/items/2a03500017766bdb0234">てめえらのRailsはオブジェクト指向じゃねえ！まずはCallbackクラス、Validatorクラスを活用しろ！ - Qiita</a></li>
      <li><a href="https://intersect.whitefusion.io/the-art-of-code/why-service-objects-are-an-anti-pattern">Why Service Objects are an Anti-Pattern — INTERSECT</a></li>
      <li><a href="https://techracho.bpsinc.jp/hachi8833/2018_04_16/55130">Service Objectがアンチパターンである理由とよりよい代替手段（翻訳）｜TechRacho（テックラッチョ）〜エンジニアの「？」を「！」に〜｜BPS株式会社</a></li>
    </ul>
  </li>
  <li><a href="https://speakerdeck.com/willnet/concerns-about-concerns">Concerns about Concerns - Speaker Deck</a></li>
  <li><a href="https://tech.kitchhike.com/entry/2018/02/28/221159">Decorator と Presenter を使い分けて、 Rails を ViewModel ですっきりさせよう - KitchHike Tech Blog</a></li>
  <li><a href="https://qiita.com/hanachin_/items/ba1dd93905567d88145c">ActiveRecordのモデルが1つだとつらい - Qiita</a></li>
</ul>

<h2 id="後編質問感想編">後編（質問・感想編）</h2>

<p>別記事にまとめました。</p>

<p><a href="/how-to-deal-with-fat-model-after">銀座Rails#21で「Fat Modelの倒し方」を発表しました 〜質問・感想編〜</a></p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p><a href="http://weblog.jamisbuck.org/2006/10/18/skinny-controller-fat-model">Buckblog: Skinny Controller, Fat Model</a> <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:a" role="doc-endnote">
      <p><a href="https://speakerdeck.com/hshimoyama/rails-with-applicationmodel">ApplicationModel のある風景 - Speaker Deck</a> <a href="#fnref:a" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:b" role="doc-endnote">
      <p><a href="https://speakerdeck.com/yasaichi/what-is-ruby-on-rails-and-how-to-deal-with-it">Ruby on Railsの正体と向き合い方 - Speaker Deck</a> <a href="#fnref:b" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:c" role="doc-endnote">
      <p><a href="https://leanpub.com/growing-rails">Growing Rails Applications in Practice</a> <a href="#fnref:c" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:6" role="doc-endnote">
      <p><a href="https://twitter.com/dhh/status/964244090224128001">https://twitter.com/dhh/status/964244090224128001</a> <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>PoEAA: <a href="https://www.martinfowler.com/eaaCatalog/singleTableInheritance.html">Single Table Inheritance</a> <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:7" role="doc-endnote">
      <p><a href="https://github.com/rails/rails/pull/26976#discussion_r87855694">https://github.com/rails/rails/pull/26976#discussion_r87855694</a> <a href="#fnref:7" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:8" role="doc-endnote">
      <p>参考: <a href="https://amzn.to/3cekmi3">『Rubyによるデザインパターン』</a> 第11章 オブジェクトを改良する：Decorator <a href="#fnref:8" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:10" role="doc-endnote">
      <p>Ruby/Rails公式の提供する機能はgemより貧弱だったりするのであしからず <a href="#fnref:10" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:10:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
  </ol>
</div>]]></content><author><name>Toshimaru</name></author><category term="presentation" /><category term="rails" /><category term="activerecord" /><summary type="html"><![CDATA[銀座Rails#21で「Fat Modelの倒し方」と題して発表してきた。　肥大化したRailsアプリケーション（Fat Rails Application）において最も辛いレイヤーはどこでしょうか？ 僕はFat Modelだと考えています。 Fat Modelを倒すためのアプローチを 1. Rails Way 2. Sub-Rails Way 3. Non-Rails Way の３つに分けて整理します。]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://blog.toshimaru.net/images/posts/ginzarails-21/og.jpg" /><media:content medium="image" url="https://blog.toshimaru.net/images/posts/ginzarails-21/og.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">ActiveRecordでhas_oneを持ったモデルをスキップして関連を定義する方法</title><link href="https://blog.toshimaru.net/belongs-to-foreign-key-and-primary-key/" rel="alternate" type="text/html" title="ActiveRecordでhas_oneを持ったモデルをスキップして関連を定義する方法" /><published>2019-11-10T00:00:00+09:00</published><updated>2021-05-31T00:00:00+09:00</updated><id>https://blog.toshimaru.net/belongs-to-foreign-key-and-primary-key</id><content type="html" xml:base="https://blog.toshimaru.net/belongs-to-foreign-key-and-primary-key/"><![CDATA[<h2 id="テーブル構成">テーブル構成</h2>

<p>とあるRailsアプリケーションでこんなテーブル構成があったとします。</p>

<p><img src="/images/posts/belongs-to-foreign-key-and-primary-key/users-posts.png" alt="table relation" /></p>

<h2 id="railsモデル定義">Railsモデル定義</h2>

<p>Railsモデルは下記のような状態です。</p>

<ul>
  <li>ユーザー（<code class="language-plaintext highlighter-rouge">User</code>）は複数の記事（<code class="language-plaintext highlighter-rouge">Post</code>）データをもっている</li>
  <li>ユーザー（<code class="language-plaintext highlighter-rouge">User</code>）は１つのプロフィール（<code class="language-plaintext highlighter-rouge">Profile</code>）データをもっている</li>
</ul>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">has_many</span> <span class="ss">:posts</span>
  <span class="n">has_one</span> <span class="ss">:profile</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Post</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">belongs_to</span> <span class="ss">:user</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Profile</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">belongs_to</span> <span class="ss">:user</span>
<span class="k">end</span>
</code></pre></div></div>

<p>モデルの生成コマンド（rails generate コマンド）は下記の通りです。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>rails g model User
<span class="gp">$</span><span class="w"> </span>rails g model Post user:references
<span class="gp">$</span><span class="w"> </span>rails g model Profile user:references
</code></pre></div></div>

<h2 id="has_oneをもったモデルをスキップする">has_oneをもったモデルをスキップする</h2>

<p>やりたいこととしてはこのモデル構成の中心にいる <code class="language-plaintext highlighter-rouge">User</code> の関連をスキップして <code class="language-plaintext highlighter-rouge">Post</code> と <code class="language-plaintext highlighter-rouge">Profile</code> を直接関連付けてやることです。つまり <strong>User has_one Profile</strong>, <strong>User has_many Posts</strong> の関係を、<strong>Profile has_many Posts</strong> の関係にしちゃおう、ということです。</p>

<p>テーブル定義で表現すると下図の赤線の部分が今回やりたい関連の定義です。</p>

<p><img src="/images/posts/belongs-to-foreign-key-and-primary-key/users-posts2.png" alt="model relation 2" /></p>

<h3 id="モデル定義">モデル定義</h3>

<p>上記のやりたいことはアソシエーションの定義において、<code class="language-plaintext highlighter-rouge">foreign_key</code>, <code class="language-plaintext highlighter-rouge">primary_key</code> などのオプションを駆使して実現可能です。</p>

<p>下記がそのアソシエーション定義の完成形となります。</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">has_many</span> <span class="ss">:posts</span>
  <span class="n">has_one</span> <span class="ss">:profile</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Post</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">belongs_to</span> <span class="ss">:user</span>
  <span class="n">belongs_to</span> <span class="ss">:profile</span><span class="p">,</span> <span class="ss">foreign_key: :user_id</span><span class="p">,</span> <span class="ss">primary_key: :user_id</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Profile</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">belongs_to</span> <span class="ss">:user</span>
  <span class="n">has_many</span> <span class="ss">:posts</span><span class="p">,</span> <span class="ss">foreign_key: :user_id</span><span class="p">,</span> <span class="ss">primary_key: :user_id</span>
<span class="k">end</span>
</code></pre></div></div>

<p>この定義により <code class="language-plaintext highlighter-rouge">Post</code> → <code class="language-plaintext highlighter-rouge">Profile</code>, <code class="language-plaintext highlighter-rouge">Profile</code> → <code class="language-plaintext highlighter-rouge">Post</code> の双方向の関連付けが定義することができました。</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="no">Post</span><span class="p">.</span><span class="nf">first</span><span class="p">.</span><span class="nf">profile</span>
<span class="c1">#  Post Load (1.2ms)  SELECT  `posts`.* FROM `posts` ORDER BY `posts`.`id` ASC LIMIT 1</span>
<span class="c1">#  Profile Load (3.9ms)  SELECT  `profiles`.* FROM `profiles` WHERE `profiles`.`user_id` = 1 LIMIT 1</span>
<span class="o">=&gt;</span> <span class="c1">#&lt;Profile id: 1, user_id: 1, ..."&gt;</span>
<span class="o">&gt;</span> <span class="no">Profile</span><span class="p">.</span><span class="nf">first</span><span class="p">.</span><span class="nf">posts</span>
<span class="c1">#  Profile Load (0.8ms)  SELECT  `profiles`.* FROM `profiles` ORDER BY `profiles`.`id` ASC LIMIT 1</span>
<span class="c1">#  Post Load (0.4ms)  SELECT  `posts`.* FROM `posts` WHERE `posts`.`user_id` = 1 LIMIT 11</span>
<span class="o">=&gt;</span> <span class="c1">#&lt;ActiveRecord::Associations::CollectionProxy [#&lt;Post id: 1, user_id: 1, ..."&gt;, #&lt;Post id: 2, user_id: 1, ...]&gt;</span>
</code></pre></div></div>

<p>上結果の通り、<code class="language-plaintext highlighter-rouge">User Load</code>を通すことなくお互いを呼び出すことができていることが確認できました。</p>

<h2 id="inverse_of-を設定する">inverse_of を設定する</h2>

<p>上記のコードでやりたいことが実現できましたが、まだ１つだけ問題があります。それは <code class="language-plaintext highlighter-rouge">foreign_key</code> オプションを使っているために、双方向の関連付けが不完全に設定されていることです。</p>

<blockquote>
  <p>Active Recordでは標準的な名前同士の関連付けのほとんどをサポートしていて、自動的に認識できます。ただし、Active Recordでスコープや次のオプションを使った場合、双方向の関連付けは自動的に認識されません。</p>

  <ul>
    <li><code class="language-plaintext highlighter-rouge">:through</code></li>
    <li><code class="language-plaintext highlighter-rouge">:foreign_key</code></li>
  </ul>
</blockquote>

<p>via. <a href="https://railsguides.jp/association_basics.html#%E5%8F%8C%E6%96%B9%E5%90%91%E9%96%A2%E9%80%A3%E4%BB%98%E3%81%91">Active Record の関連付け - Rails ガイド</a></p>

<p>実際に試してみましょう。すると下記の通り、同じidを持ったインスタンスにもかかわらず違うオブジェクトとして生成されていることがわかります。</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">profile1</span> <span class="o">=</span> <span class="no">Profile</span><span class="p">.</span><span class="nf">first</span>
<span class="o">=&gt;</span> <span class="c1">#&lt;Profile id: 1, user_id: 1, ..."&gt;</span>
<span class="o">&gt;</span> <span class="n">profile2</span> <span class="o">=</span> <span class="n">profile1</span><span class="p">.</span><span class="nf">posts</span><span class="p">.</span><span class="nf">first</span><span class="p">.</span><span class="nf">profile</span>
<span class="o">=&gt;</span> <span class="c1">#&lt;Profile id: 1, user_id: 1, ..."&gt;</span>
<span class="o">&gt;</span> <span class="n">profile1</span><span class="p">.</span><span class="nf">equal?</span> <span class="n">profile2</span>
<span class="o">=&gt;</span> <span class="kp">false</span>
</code></pre></div></div>

<h3 id="モデル定義inverse_of-version">モデル定義（inverse_of version）</h3>

<p>これを解決するために <code class="language-plaintext highlighter-rouge">inverse_of</code> を設定します。上述のコードを下記のように変更します。</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">has_many</span> <span class="ss">:posts</span>
  <span class="n">has_one</span> <span class="ss">:profile</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Post</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">belongs_to</span> <span class="ss">:user</span>
  <span class="n">belongs_to</span> <span class="ss">:profile</span><span class="p">,</span> <span class="ss">foreign_key: :user_id</span><span class="p">,</span> <span class="ss">primary_key: :user_id</span><span class="p">,</span> <span class="ss">inverse_of: :posts</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Profile</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">belongs_to</span> <span class="ss">:user</span>
  <span class="n">has_many</span> <span class="ss">:posts</span><span class="p">,</span> <span class="ss">foreign_key: :user_id</span><span class="p">,</span> <span class="ss">primary_key: :user_id</span><span class="p">,</span> <span class="ss">inverse_of: :profile</span>
<span class="k">end</span>
</code></pre></div></div>

<p>これで下記コードは同じオブジェクトとなり、<code class="language-plaintext highlighter-rouge">true</code>を返すようになります。</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">profile1</span> <span class="o">=</span> <span class="no">Profile</span><span class="p">.</span><span class="nf">first</span>
<span class="o">&gt;</span> <span class="n">profile2</span> <span class="o">=</span> <span class="n">profile1</span><span class="p">.</span><span class="nf">posts</span><span class="p">.</span><span class="nf">first</span><span class="p">.</span><span class="nf">profile</span>
<span class="o">&gt;</span> <span class="n">profile1</span><span class="p">.</span><span class="nf">equal?</span> <span class="n">profile2</span>
<span class="o">=&gt;</span> <span class="kp">true</span>
</code></pre></div></div>

<h2 id="過去に書いた関連記事">過去に書いた関連記事</h2>

<ul>
  <li><a href="/belongs_to-through/">ActiveRecordでhas_many, throughとは逆の関連を定義する</a></li>
</ul>

<h2 id="参考">参考</h2>

<ul>
  <li><a href="https://railsdoc.github.io/classes/ActiveRecord/Associations/ClassMethods.html#method-i-belongs_to">ActiveRecord::Associations::ClassMethods - belongs_to | RailsDoc(β)</a></li>
  <li><a href="https://railsdoc.github.io/classes/ActiveRecord/Associations/ClassMethods.html#method-i-has_many">ActiveRecord::Associations::ClassMethods - has_many | RailsDoc(β)</a></li>
</ul>]]></content><author><name>Toshimaru</name></author><category term="activerecord" /><category term="rails" /><summary type="html"><![CDATA[Railsモデルは下記のような状態です。 ユーザー（User）は複数の記事（Post）データをもっている ユーザー（User）は１つのプロフィール（Profile）データをもっている　やりたいこととしてはこのモデル構成の中心にいる User の関連をスキップして Post と Profile を直接関連付けてやることです。つまり User has_one Profile, User has_many Posts の関係を、Profile has_many Posts の関係にしちゃおう、ということです。]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://blog.toshimaru.net/images/posts/belongs-to-foreign-key-and-primary-key/og.png" /><media:content medium="image" url="https://blog.toshimaru.net/images/posts/belongs-to-foreign-key-and-primary-key/og.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">railsdm2018で「ActiveRecordデータ処理アンチパターン」を発表しました</title><link href="https://blog.toshimaru.net/rdm2018-active-record-anti-patterns/" rel="alternate" type="text/html" title="railsdm2018で「ActiveRecordデータ処理アンチパターン」を発表しました" /><published>2018-03-27T00:00:00+09:00</published><updated>2018-03-27T00:00:00+09:00</updated><id>https://blog.toshimaru.net/rdm2018-active-record-anti-patterns</id><content type="html" xml:base="https://blog.toshimaru.net/rdm2018-active-record-anti-patterns/"><![CDATA[<p><a href="https://railsdm.github.io/2018/">Rails Developers Meetup 2018</a>で「ActiveRecordデータ処理アンチパターン」というタイトルで発表してきました。</p>

<h2 id="発表資料">発表資料</h2>

<script async="" class="speakerdeck-embed" data-id="2bb9d7ceea4b4987bf4c8618a53a1e68" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js"></script>

<h2 id="発表概要">発表概要</h2>

<blockquote>
  <p>ActiveRecordはWebエンジニア達が嫌う（？）SQLを書かずとも、Rubyオブジェクトで気軽にデータベースへアクセスできる魔法のようなツールです。しかし便利な反面、何も考えずにゴリゴリActiveRecordを使ってDBアクセスしていると、劇的に重たいクエリが発行されたり非効率的なクエリが量産されたりします。</p>

  <p>本発表ではそれらActiveRecordで陥りがちな罠をパターン化し、ActiveRecordデータ処理アンチパターンとして発表します。</p>

  <p>※発表では実際のサンプルコードとともにパフォーマンスの計測結果も紹介します。</p>
</blockquote>

<h2 id="事前に公開したエントリ">事前に公開したエントリ</h2>

<p>発表資料に出てくる最初の事例はこちらがベースの事例となっています。</p>

<blockquote class="twitter-tweet" data-lang="ja"><p lang="ja" dir="ltr">今月末のRails Developer Meetupに先駆けてRailsの遅いバッチ処理を400倍速くする話を書きました  | Rails/ActiveRecord バッチ処理の最適化 - Hack Your Design! <a href="https://t.co/i7JZnZcuLc">https://t.co/i7JZnZcuLc</a></p>&mdash; toshimaru (@toshimaru_e) <a href="https://twitter.com/toshimaru_e/status/970546164725501952?ref_src=twsrc%5Etfw">March 5, 2018</a></blockquote>

<h2 id="ソースコード">ソースコード</h2>

<p>実際使ったコード、ベンチマーク結果はこちらに上がってます。コードは<code class="language-plaintext highlighter-rouge">lib/tasks/batch.rake</code>、スキーマは<code class="language-plaintext highlighter-rouge">schema.rb</code>、シードデータは<code class="language-plaintext highlighter-rouge">db/*_seed.csv</code>、ベンチマーク結果はCircleCIをそれぞれ参照ください。</p>

<p><a href="https://github.com/toshimaru/rdm-rails5.1">https://github.com/toshimaru/rdm-rails5.1</a></p>

<h2 id="発表モチベーション">発表モチベーション</h2>

<p>今回の発表に至るモチベーションとしては、僕が実際に踏んだActiveRecordの重い処理とか他のエンジニアが書いたActiveRecordコードのパフォーマンス改善のための修正などをやっている中で、その良くない処理及びそれに対する解決アプローチがパターン化できると思ったからです。</p>

<p>僕のアタマの中に「こういうアンチパターンがありそう」というアンチパターン候補がある程度リストアップされていたので、今回の発表を機にそれらにそれっぽい名前を付けて、同時に机上の空論にならないようにそれらをコードに落として、聞き手がイメージしやすいように具体的な事例とともに紹介しました。</p>

<p>結果として、自分の中にあったActiveRecordアンチパターンを命名とともに整理できたことは大変良かったと思っています。またこの資料さえチームに共有しとけば、今後レビューのときとかでもアンチパターンに関するコミュニケーションがしやすくなって個人的に助かりそうです。</p>

<h2 id="紹介したアンチパターン">紹介したアンチパターン</h2>

<p>発表内で紹介したアンチパターンがこちらです。</p>

<ol>
  <li>All Each Pattern</li>
  <li>N+1 Update Queries Pattern</li>
  <li>Ruby Aggregation Pattern</li>
  <li>N+1 Queries Pattern</li>
  <li>Unnecessary Query Pattern</li>
  <li>Unnecessary Mode Initialization Pattern</li>
</ol>

<h2 id="紹介できなかったアンチパターン">紹介できなかったアンチパターン</h2>

<p>何かしらアンチパターン化できそうだけど、時間の都合上しなかったアンチパターンがこちらです。発表しなかったので命名は適当です。</p>

<h3 id="なんでもincludesパターン">なんでもincludesパターン</h3>

<p><code class="language-plaintext highlighter-rouge">joins</code>で良いのになんでも<code class="language-plaintext highlighter-rouge">includes</code>で解決しようとしちゃうパターン。このへんは下記の解説に詳しいです。</p>

<p><a href="https://qiita.com/k0kubun/items/80c5a5494f53bb88dc58">ActiveRecordのjoinsとpreloadとincludesとeager_loadの違い - Qiita</a></p>

<h3 id="too-many-find_or_create_by-パターン">Too many find_or_create_by パターン</h3>

<p><code class="language-plaintext highlighter-rouge">find_or_create_by</code>は、オブジェクトが存在する場合は取得、なければ作成って挙動をするやつです。これをループ内で使いまくっちゃうパターン。</p>

<p>そんなときはSQLのUPSERTの機能を使うのが得策。具体的にはMySQLであれば<code class="language-plaintext highlighter-rouge">INSERT...ON DUPLICATE KEY UPDATE</code>です。</p>

<p>残念なことにUPSERTはActiveRecordの標準機能では提供されていないので、<a href="https://github.com/zdennis/activerecord-import">activerecord-import</a>などのgemを使って解決する必要があります。</p>

<h3 id="has_many関連のcount方法いろいろあるよ問題">has_many関連のcount方法いろいろあるよ問題</h3>

<p>ちゃんとパターン化できていませんが、この問題もなかなか難しい問題です。どのメソッド使ったらよいかはケースバイケースで変わってくるので詳しくは下記を参照されたし。</p>

<p><a href="https://qiita.com/nay3/items/1cda39fb58569d832203">ActiveRecord の has_many関連、件数を調べるメソッドはどれを使えばいい？ - Qiita</a></p>

<h2 id="q--a">Q &amp; A</h2>

<h3 id="アンチパターンの出典は">アンチパターンの出典は？</h3>

<p>全部オレです（笑</p>

<p>一応元ネタというかインスパイアを受けた本としては発表内でも紹介している『SQLアンチパターン』です。</p>

<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=toshimaru-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=4873115892&amp;linkId=6903fbe4f4a55cf4f47b4036bf2f350a"></iframe>

<p>こちらの本が原著は英語で書かれており、それに倣うかたちで英語でアンチパターンを命名しました。まぁ平たく言うとカッコつけて英語にしました以上の理由はありません :smile:</p>

<h3 id="事例１usercreated_atにindex貼らないの">（事例１）User.created_atにINDEX貼らないの？</h3>

<p>下記二点の理由により貼りませんでした。</p>

<ol>
  <li>前提事項としてDBの最適化はしないと述べた</li>
  <li><code class="language-plaintext highlighter-rouge">User.created_at</code> にINDEXを貼ってもINDEX効かない</li>
</ol>

<p><code class="language-plaintext highlighter-rouge">User.created_at</code>にINDEX(<code class="language-plaintext highlighter-rouge">index_users_on_created_at</code>)を貼ったあとの実行計画がこちらになります。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; EXPLAIN UPDATE `users` SET point = point + 100 WHERE (created_at &gt;= '2017-01-01') \G
*************************** 1. row ***************************
           id: 1
  select_type: UPDATE
        table: users
   partitions: NULL
         type: index
possible_keys: index_users_on_created_at
          key: PRIMARY
      key_len: 8
          ref: NULL
         rows: 99574
     filtered: 100.00
        Extra: Using where
1 row in set (0.00 sec)
</code></pre></div></div>

<p>INDEX貼ってても対象範囲が大きいとINDEX効かなくなるんです。そして今回のケースはそれに当たります。（この挙動、実は僕も全然知りませんでした…）</p>

<blockquote class="twitter-tweet" data-lang="ja"><p lang="ja" dir="ltr">mysqlで検索の対象範囲が大きくなりすぎるとindexが効かなくなるの知らなかった | [MYSQL] datetimeカラムのインデックスの使われ方をテストしてみた │ revdev <a href="https://t.co/2JK7VD7Ttv">https://t.co/2JK7VD7Ttv</a></p>&mdash; toshimaru (@toshimaru_e) <a href="https://twitter.com/toshimaru_e/status/974924182369722368?ref_src=twsrc%5Etfw">March 17, 2018</a></blockquote>

<p>テストとして条件の範囲を小さくした実行計画がこちらになります。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; EXPLAIN UPDATE `users` SET point = point + 100 WHERE (created_at &gt;= '2018-01-01') \G
*************************** 1. row ***************************
           id: 1
  select_type: UPDATE
        table: users
   partitions: NULL
         type: range
possible_keys: index_users_on_created_at
          key: index_users_on_created_at
      key_len: 5
          ref: const
         rows: 5903
     filtered: 100.00
        Extra: Using where
1 row in set (0.00 sec)
</code></pre></div></div>

<p>きちんとこちらではINDEXが効いてます。</p>

<h3 id="事例２改善１のコードのモデルってロードされている">（事例２）改善１のコードのモデルってロードされている？</h3>

<p>会場であった質問です。こちらはRails consoleで実際のコードを動かしてあげれば一目瞭然です。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; Post.group(:user_id).select("user_id, SUM(like_count) AS like_count").order("like_count DESC") .limit(100)
  Post Load (976.6ms)  SELECT  user_id, SUM(like_count) AS like_count FROM `posts` GROUP BY `posts`.`user_id` ORDER BY like_count DESC LIMIT 11
=&gt; #&lt;ActiveRecord::Relation [#&lt;Post id: nil, user_id: 2632, like_count: 832&gt;, #&lt;Post id: nil, user_id: 51965, like_count: 800&gt;, #&lt;Post id: nil, user_id: 25068, like_count: 783&gt;, ...]&gt;

&gt; Post.group(:user_id).order("SUM(like_count) DESC") .limit(3000).pluck(:user_id)
   (668.3ms)  SELECT  `posts`.`user_id` FROM `posts` GROUP BY `posts`.`user_id` ORDER BY SUM(like_count) DESC LIMIT 3000
=&gt; [2632, 51965, 25068, 8515, 84933, 67763, 89631, 69494, 78805, 17541, 53344, 7618, 92652, 13704, 94308, 96778, ...
</code></pre></div></div>

<p>一つ目の<code class="language-plaintext highlighter-rouge">.select</code>を使ったコードはログに<code class="language-plaintext highlighter-rouge">Post Load</code>と出現している通り、Postモデルがロードされている一方、<code class="language-plaintext highlighter-rouge">.pluck</code>のほうでは<code class="language-plaintext highlighter-rouge">Post Load</code>とはなにも出ず単純に走ったクエリのみがログに出力されています。</p>

<h3 id="紹介したアンチパターンどれくらいの件数で障害に繋がりそう">紹介したアンチパターン、どれくらいの件数で障害に繋がりそう？</h3>

<p>今回紹介した事例は数千件-数十万くらいの程度のデータ量なのでそこまで酷いパフォーマンス結果は出ませんでしたが、例えば事例１でこれがUserレコード数百万件とか、事例３でレコードが数十万件くらいのオーダーになってくるとボトルネックが表出しそうかな、という印象です。</p>

<p>いずれにせよそこそこの規模のアプリケーションになってくると、数百万レコードを扱うのは当たり前の世界になってくると思うので、そのレコード数をどうActiveRecordの世界で上手に扱うは逃げられないテーマになってくるかなと思います。</p>

<h2 id="発表を終えて">発表を終えて</h2>

<p>30minsと長めの発表は<a href="/aws-summit-tokyo-2015/">AWS Summitぶり</a>だったので時間配分にやや不安があったけど、当日は発表を巻くこともなく余裕をもって25分くらいで発表を終えられたのでよかったです。</p>

<h2 id="その他の資料">その他の資料</h2>

<ul>
  <li>Rails Developer Meetup 2018の全体の発表資料はこちら: <a href="https://qiita.com/dyoshimitsu/items/20a41ab656d2da80e4d9">Rails Developers Meetup 2018 スライドまとめ - Qiita</a></li>
</ul>]]></content><author><name>Toshimaru</name></author><category term="presentation" /><category term="activerecord" /><category term="rails" /><summary type="html"><![CDATA[Rails Developers Meetup 2018で「ActiveRecordデータ処理アンチパターン」というタイトルで発表してきました。紹介したアンチパターン 発表内で紹介したアンチパターンがこちらです。 All Each Pattern N+1 Update Queries Pattern Ruby Aggregation Pattern N+1 Queries Pattern Unnecessary Query Pattern Unnecessary Mode Initialization Pattern 紹介できなかったアンチパターン 何かしらアンチパターン化できそうだけど、時間の都合上しなかったアンチパターンがこちらです。発表しなかったので命名は適当です。]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://blog.toshimaru.net/images/posts/railsdm/rdm2018.png" /><media:content medium="image" url="https://blog.toshimaru.net/images/posts/railsdm/rdm2018.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Rails/ActiveRecord バッチ処理の最適化</title><link href="https://blog.toshimaru.net/rails-batch-optimization/" rel="alternate" type="text/html" title="Rails/ActiveRecord バッチ処理の最適化" /><published>2018-03-05T00:00:00+09:00</published><updated>2018-03-05T00:00:00+09:00</updated><id>https://blog.toshimaru.net/rails-batch-optimization</id><content type="html" xml:base="https://blog.toshimaru.net/rails-batch-optimization/"><![CDATA[<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">Railsのバッチ処理最適化の記事書いたら需要あるかな</p>&mdash; toshimaru (@toshimaru_e) <a href="https://twitter.com/toshimaru_e/status/936796457931128832?ref_src=twsrc%5Etfw">December 2, 2017</a></blockquote>

<p>ということで今日はRailsバッチ処理の最適化について書いてみたいと思います。</p>

<h2 id="検証環境">検証環境</h2>

<p>コードの検証に使った環境は下記の通りです。</p>

<ul>
  <li>macOS High Sierra (2.3 GHz Intel Core i5 / メモリ8G)</li>
  <li>Ruby 2.5</li>
  <li>Rails 5.1</li>
</ul>

<h2 id="前提条件">前提条件</h2>

<p>最適化の前提条件としては下記の通りです。</p>

<ul>
  <li>バッチはrakeタスクとして実行する</li>
  <li>今回、最適化対象とするのは <strong>Userモデルのバッチ処理</strong>
    <ul>
      <li>使用するUserモデルは<a href="https://github.com/plataformatec/devise/">devise</a>で作られるUserモデル(<code class="language-plaintext highlighter-rouge">rails generate devise:install</code>)を基本として、そのスキーマ定義にint型のpointカラムをつけたもの</li>
      <li>pointカラムは登録ユーザーが自由につかえるポイントの意</li>
    </ul>
  </li>
  <li>Userデータとして事前に <strong>50万件のユーザーデータ</strong> を投入しておく</li>
  <li><a href="https://dalibornasevic.com/posts/68-processing-large-csv-files-with-ruby">こちらのコード</a>を参考に処理の <strong>実行時間</strong> と <strong>メモリ使用量</strong> を計測する</li>
  <li><code class="language-plaintext highlighter-rouge">execute</code>などによる直接SQL実行はせずにDB操作を行う</li>
  <li>シンプルにするために、登録日 = <code class="language-plaintext highlighter-rouge">User.created_at</code>とする
    <ul>
      <li>Userのタイムゾーンは無いものとする（すべてUTCとして扱う）</li>
    </ul>
  </li>
  <li>データベースのトランザクション処理は考慮しない</li>
  <li>今回行う最適化の対象はアプリケーションコードでありDBの最適化は考えない</li>
</ul>

<h2 id="オリジナルコード">オリジナルコード</h2>

<p>さて今回最適化するコードは下記です。処理内容としては <strong>全ユーザーの中から2017年以降の登録ユーザーへ100ポイントを付与する</strong> というものです。いかにも販促活動の一環としてありそうな話です（<code class="language-plaintext highlighter-rouge">2017年以降</code>のところの条件は別になんでも良かったのですが、処理対象をある程度確保するために今回はそのように設定しました）。</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Task: batch:original</span>
<span class="no">User</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">user</span><span class="o">|</span>
  <span class="k">if</span> <span class="n">user</span><span class="p">.</span><span class="nf">created_at</span> <span class="o">&gt;=</span> <span class="s2">"2017-01-01"</span>
    <span class="n">user</span><span class="p">.</span><span class="nf">point</span> <span class="o">+=</span> <span class="mi">100</span>
    <span class="n">user</span><span class="p">.</span><span class="nf">save</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>あなたはこのコードをぱっと見てどこが悪いかすぐにわかりますか？（言うまでもなくこのコードは問題アリアリのコードです!!）</p>

<p>中級者以上のRailsエンジニアであれば「そんなコードは絶対書かないよ！」と思うかもしれませんが、「RailsでWebプログラミングを初めてまだ一ヶ月です！」みたいな初級エンジニアであれば上記のように書いても全然おかしくはないコードだと思います。</p>

<h3 id="ベンチマーク">ベンチマーク</h3>

<p>まずはこの問題のあるコードがどれだけ時間がかかっているかを計測してみましょう。</p>

<p>※ 前提条件で書いた通り、<a href="https://dalibornasevic.com/posts/68-processing-large-csv-files-with-ruby">こちらのコード</a>を参考に時間とメモリ使用量を計測します。また結果は数回実施した上で大きく外れていない平均的なスコア結果を掲載します。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>rake batch:original
<span class="go">Time: 339.42 secs
Memory: 2219.72 MB
</span></code></pre></div></div>

<p>実行時間は340秒、メモリ使用量は2200MB程でした。今回の最適化のゴールは <strong>この処理時間をできるだけ速くして、あわせてメモリ使用量も抑えることです。</strong></p>

<p>では早速このコードを最適化していきましょう。</p>

<h2 id="最適化1-簡単な最適化">最適化1: 簡単な最適化</h2>

<p>まずは簡単な最適化から始めましょう。日付の比較は<code class="language-plaintext highlighter-rouge">String</code>を使うよりも<code class="language-plaintext highlighter-rouge">Date</code>クラスを使ったほうが速そうです。また、ループの中で何度も同じ値が使われるのも良くないので定数に切り出しちゃいましょう。結果、下記のコードのようになりました。</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Task: batch:improvement1</span>
<span class="no">POINT_DATE</span> <span class="o">=</span> <span class="no">Date</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">2017</span><span class="p">)</span>

<span class="no">User</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">user</span><span class="o">|</span>
  <span class="k">if</span> <span class="n">user</span><span class="p">.</span><span class="nf">created_at</span> <span class="o">&gt;=</span> <span class="no">POINT_DATE</span>
    <span class="n">user</span><span class="p">.</span><span class="nf">point</span> <span class="o">+=</span> <span class="mi">100</span>
    <span class="n">user</span><span class="p">.</span><span class="nf">save</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="ベンチマーク-1">ベンチマーク</h3>

<p>さて計測結果です。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>rake batch:improvement1
<span class="go">Time: 320.0 secs
Memory: 2244.71 MB
</span></code></pre></div></div>

<p>メモリ使用量は変わらず、実行時間は10数秒程度速くなったくらいでしょうか。小さな最適化レベルでまだまだ全然速くなったとは言えません。</p>

<h2 id="最適化2-where--each-を使う">最適化2: where &amp; each を使う</h2>

<p>次はもう少し本格的な最適化を入れていきましょう。</p>

<p>まずは<code class="language-plaintext highlighter-rouge">User.all.each</code>で全件ユーザーを取得している点が真っ先に気になるところです。これは <strong>全件取得せず2017年以降の登録ユーザーをあらかじめフィルターしてからループさせる</strong> ほうが良さそうです。</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Task: batch:improvement2</span>
<span class="no">User</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"created_at &gt;= ?"</span><span class="p">,</span> <span class="no">POINT_DATE</span><span class="p">).</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">user</span><span class="o">|</span>
  <span class="n">user</span><span class="p">.</span><span class="nf">point</span> <span class="o">+=</span> <span class="mi">100</span>
  <span class="n">user</span><span class="p">.</span><span class="nf">save</span>
<span class="k">end</span>
</code></pre></div></div>

<p>あらかじめ処理対象ユーザーだけをフィルターできているので、ループ内の<code class="language-plaintext highlighter-rouge">if</code>も消すことができました。</p>

<h3 id="ベンチマーク-2">ベンチマーク</h3>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>rake batch:improvement2
<span class="go">Time: 294.35 secs
Memory: 1623.5 MB
</span></code></pre></div></div>

<p>実行時間が前の結果より20秒程改善、メモリ消費もユーザーを全件取得する必要がなくなった分、500MB程空きました。良い感じですね。</p>

<h2 id="最適化3-find_each-を使う">最適化3: find_each を使う</h2>

<p>ちょっと待って下さい、大量データを一度にロードしなくてもいいように、ActiveRecordが<a href="http://api.rubyonrails.org/classes/ActiveRecord/Batches.html#method-i-find_each">find_each</a>という便利メソッドを用意してくれてるのでした。これを使わない手はないでしょう。</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Task: batch:improvement3</span>
<span class="no">User</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"created_at &gt;= ?"</span><span class="p">,</span> <span class="no">POINT_DATE</span><span class="p">).</span><span class="nf">find_each</span> <span class="k">do</span> <span class="o">|</span><span class="n">user</span><span class="o">|</span>
  <span class="n">user</span><span class="p">.</span><span class="nf">point</span> <span class="o">+=</span> <span class="mi">100</span>
  <span class="n">user</span><span class="p">.</span><span class="nf">save</span>
<span class="k">end</span>
</code></pre></div></div>

<p>これで少しつづユーザーをロードして処理してくれるようになり、メモリに優しいコードになったと思います。</p>

<h3 id="ベンチマーク-3">ベンチマーク</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ rake batch:improvement3
Time: 290.88 secs
Memory: 31.41 MB
</code></pre></div></div>

<p>実行時間が前の結果と変わらないこそすれ、<strong>メモリ使用量は前の結果の50分の一となりました。</strong> 大きな改善と言っていいでしょう。</p>

<h2 id="最適化4-in_batches--update_all-を使う">最適化4: in_batches &amp; update_all を使う</h2>

<p>ここで一件一件<code class="language-plaintext highlighter-rouge">update</code>が走る点が気になってきました。そこはActiveRecordの<a href="http://api.rubyonrails.org/classes/ActiveRecord/Relation.html#method-i-update_all">update_all</a>を使ってまとめて更新するようにしてあげれば解決できそうです。</p>

<p>また<code class="language-plaintext highlighter-rouge">update_all</code>は<code class="language-plaintext highlighter-rouge">ActiveRecord::Relation</code>のメソッドですが、<code class="language-plaintext highlighter-rouge">ActiveRecord::Relation</code>を先の<code class="language-plaintext highlighter-rouge">find_each</code>のように返してくれる便利メソッドが<a href="http://api.rubyonrails.org/classes/ActiveRecord/Batches.html#method-i-in_batches">in_batches</a>です。</p>

<p>この<code class="language-plaintext highlighter-rouge">in_batches</code>と<code class="language-plaintext highlighter-rouge">update_all</code>を組み合わせて処理してあげれば効率良く更新できそうな気がします。</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Task: batch:improvement4</span>
<span class="no">User</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"created_at &gt;= ?"</span><span class="p">,</span> <span class="no">POINT_DATE</span><span class="p">).</span><span class="nf">in_batches</span> <span class="k">do</span> <span class="o">|</span><span class="n">users</span><span class="o">|</span>
  <span class="n">users</span><span class="p">.</span><span class="nf">update_all</span><span class="p">(</span><span class="s2">"point = point + 100"</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="ベンチマーク-4">ベンチマーク</h3>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>rake batch:improvement4
<span class="go">Time: 2.46 secs
Memory: 7.26 MB
</span></code></pre></div></div>

<p><strong>実行時間が100倍速くなりました。</strong> 劇的な改善と言っていいでしょう。またメモリの使用量も前の結果よりさらに抑えられています。</p>

<h2 id="最適化5-where--update_all">最適化5: where &amp; update_all</h2>

<p>勘の良い方なら既にお気づきですね。…ハイ、先のコードは<code class="language-plaintext highlighter-rouge">in_batches</code>すら不要です。単純にupdate対象を<code class="language-plaintext highlighter-rouge">where</code>でフィルターした上で<code class="language-plaintext highlighter-rouge">update_all</code>すれば良さそうです。出来上がったコードがこちら。</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Task: batch:improvement5</span>
<span class="no">User</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"created_at &gt;= ?"</span><span class="p">,</span> <span class="no">POINT_DATE</span><span class="p">).</span><span class="nf">update_all</span><span class="p">(</span><span class="s2">"point = point + 100"</span><span class="p">)</span>
</code></pre></div></div>

<p>一行のシンプルなコードに仕上がりました。</p>

<h3 id="ベンチマーク-5">ベンチマーク</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ rake batch:improvement5
Time: 0.78 secs
Memory: 0.82 MB
</code></pre></div></div>

<p><strong>実行時間は前の結果より3倍早くなり、メモリ使用量もさらに10分の一まで抑えられました。</strong></p>

<p>これを今回の最適化コードの最終形としたいと思います。</p>

<hr />

<p><em>追記ここから</em></p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">これcreated_atにインデックスがあろうがなかろうが全舐めして1秒弱で終わるレコード数ならいいのだけど、そうだとしてもsaveをupdate_allにした時点でcallbackが起きなくなって元と等価ではなくなるから仕事で真似するときは詳しい人にちゃんとレビューしてもらってから投入したほうがよさそう。</p>&mdash; Ryuta Kamizono (@kamipo) <a href="https://twitter.com/kamipo/status/970574529452900352?ref_src=twsrc%5Etfw">March 5, 2018</a></blockquote>

<p>kamipoさんからご指摘頂いたとおり、<code class="language-plaintext highlighter-rouge">update_all</code>は通常のActiveRecordの更新とは異なりcallback, validationをスキップするという仕様となっております。よってオリジナルコードとは等価な処理では無くなっているので、実際の現場においては<code class="language-plaintext highlighter-rouge">save</code>から<code class="language-plaintext highlighter-rouge">update_all</code>に変更する際は「本当にcallback, validationスキップしても大丈夫なんだっけ？」ということをしっかり考えてから実施するようにしてください。</p>

<blockquote>
  <p>it does not trigger Active Record callbacks or validations</p>
</blockquote>

<p>http://api.rubyonrails.org/classes/ActiveRecord/Relation.html#method-i-update_all</p>

<p>なお今回のコード例ではモデルのcallback, validationをスキップしても問題ないコードとして話を進めています。</p>

<p>加えて、今回データベースの最適化は最適化の範囲外としたので<code class="language-plaintext highlighter-rouge">created_at</code>カラムのindexは貼りませんでした。実際の現場においてはRubyのコードレベルの最適化に加えてデータベースの最適化も考えてINDEXを貼ることも検討したほうがいいでしょう。</p>

<p><em>追記ここまで</em></p>

<hr />

<h2 id="最終結果">最終結果</h2>

<p>オリジナルコードと最適化済みの最終コードを比較すると下記の通りの改善が確認できました。</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>実行時間</th>
      <th>メモリ消費</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>オリジナルコード</td>
      <td>339.42 secs</td>
      <td>2219.72 MB</td>
    </tr>
    <tr>
      <td>最適化コード</td>
      <td>0.78 secs</td>
      <td>0.82 MB</td>
    </tr>
    <tr>
      <td>改善結果</td>
      <td>:rocket: <strong>435倍高速化</strong></td>
      <td>:recycle: <strong>約2700分の一まで省メモリ化</strong></td>
    </tr>
  </tbody>
</table>

<h2 id="activerecordデータ処理アンチパターンで発表します">「ActiveRecordデータ処理アンチパターン」で発表します</h2>

<p>上述したようなオリジナルコードは極端な例ではありますが、ActiveRecordでデータを扱うときはきちんと遅くならないように意識してバッチ処理を書かないと極端に遅くなってしまうケースがあります。</p>

<p>そんなActiveRecordデータ処理で陥りがちな罠をパターン化し今月のRails Develper Meetupにて発表する予定です。ご興味あれば是非。</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">3月25日に「ActiveRecordアンチパターン」的な内容で発表しますー | Rails Developers Meetup 2018: Day 2｜IT勉強会ならTECH PLAY［テックプレイ］ <a href="https://t.co/QJgdMF92Sr">https://t.co/QJgdMF92Sr</a></p>&mdash; toshimaru (@toshimaru_e) <a href="https://twitter.com/toshimaru_e/status/960340809005506561?ref_src=twsrc%5Etfw">February 5, 2018</a></blockquote>

<h2 id="参考リンク">参考リンク</h2>

<ul>
  <li><a href="http://api.rubyonrails.org/classes/ActiveRecord/Relation.html">ActiveRecord::Relation</a></li>
  <li><a href="http://api.rubyonrails.org/classes/ActiveRecord/Batches.html">ActiveRecord::Batches</a></li>
</ul>]]></content><author><name>Toshimaru</name></author><category term="rails" /><category term="activerecord" /><summary type="html"><![CDATA[さて今回最適化するコードは下記です。処理内容としては 全ユーザーの中から2017年以降の登録ユーザーへ100ポイントを付与する というものです。いかにも販促活動の一環としてありそうな話です。あなたはこのコードをぱっと見てどこが悪いかすぐにわかりますか？ 中級者以上のRailsエンジニアであれば「そんなコードは絶対書かないよ！」と思うかもしれませんが、「RailsでWebプログラミングを初めてまだ一ヶ月です！」みたいな初級エンジニアであれば上記のように書いても全然おかしくはないコードだと思います。]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://blog.toshimaru.net/images/posts/railsdm/ar-optimization.png" /><media:content medium="image" url="https://blog.toshimaru.net/images/posts/railsdm/ar-optimization.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Railsのfind_eachの挙動について調べた</title><link href="https://blog.toshimaru.net/rails-find_each/" rel="alternate" type="text/html" title="Railsのfind_eachの挙動について調べた" /><published>2015-11-12T00:00:00+09:00</published><updated>2015-11-12T00:00:00+09:00</updated><id>https://blog.toshimaru.net/rails-find_each</id><content type="html" xml:base="https://blog.toshimaru.net/rails-find_each/"><![CDATA[<p>Railsの<a href="http://apidock.com/rails/ActiveRecord/Batches/ClassMethods/find_each">find_each</a>がどんな挙動をするか気になったので調べてみた。</p>

<h2 id="find_each-とは">find_each とは</h2>

<p>バッチ処理などにおいてActiveRecordで効率的に大量データを処理したいときに使うメソッド。大量データまるっと全部取ってきてメモリ展開して処理しちゃあアカンよねってことで、データを徐々に展開して処理したいときに使う。</p>

<blockquote>
  <p>Railsには find_each というメソッドが用意されています。通常の each メソッドを使用すると、全データをまとめてメモリに展開してから処理を開始します。そのため、十分にメモリに載るデータ量であれば何も問題ないですが、数百万、数千万というデータ量になってくるとメモリに載りきらずに溢れてしまって大変なことになります。</p>

  <ul>
    <li>find: 全データをメモリに展開してから処理</li>
    <li>find_each: 少しずつデータをメモリに展開しつつ処理</li>
  </ul>

  <p>そういうときには find_each メソッドを使いましょう。</p>
</blockquote>

<p><a href="http://blog.livedoor.jp/sasata299/archives/51882704.html">Railsで大量のデータをまとめて更新するならfind_each使うよね - (ﾟ∀ﾟ)o彡 sasata299’s blog</a></p>

<h2 id="素の-find_each">素の find_each</h2>

<p>まずはUserテーブルに1万件くらいデータを作って素直に<code class="language-plaintext highlighter-rouge">find_each</code>してみる。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; User.find_each{|a|}
  User Load (2.7ms)  SELECT  `users`.* FROM `users`  ORDER BY `users`.`id` ASC LIMIT 1000
  User Load (2.6ms)  SELECT  `users`.* FROM `users` WHERE (`users`.`id` &gt; 1001)  ORDER BY `users`.`id` ASC LIMIT 1000
  User Load (4.7ms)  SELECT  `users`.* FROM `users` WHERE (`users`.`id` &gt; 2001)  ORDER BY `users`.`id` ASC LIMIT 1000
  ...
</code></pre></div></div>

<p>デフォルトでは<code class="language-plaintext highlighter-rouge">ORDER BY id</code>で全件取得して1000件ずつ分割(<code class="language-plaintext highlighter-rouge">limit 1000</code>)して処理していくようなかたち。</p>

<h2 id="order付き-find_each">order付き find_each</h2>

<p>では<code class="language-plaintext highlighter-rouge">order</code>を付けて<code class="language-plaintext highlighter-rouge">find_each</code>したらどうなるのだろう？</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; User.order(created_at: :desc).find_each{|a|}
Scoped order and limit are ignored, it's forced to be batch order and batch size
  User Load (3.8ms)  SELECT  `users`.* FROM `users`  ORDER BY `users`.`id` ASC LIMIT 1000
  User Load (3.0ms)  SELECT  `users`.* FROM `users` WHERE (`users`.`id` &gt; 1001)  ORDER BY `users`.`id` ASC LIMIT 1000
  User Load (2.3ms)  SELECT  `users`.* FROM `users` WHERE (`users`.`id` &gt; 2001)  ORDER BY `users`.`id` ASC LIMIT 1000
  ...
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Scoped order and limit are ignored</code>ということで<code class="language-plaintext highlighter-rouge">order</code>と<code class="language-plaintext highlighter-rouge">limit</code>は無視されるようです。</p>

<h2 id="limit付き-find_each">limit付き find_each</h2>

<p>じゃあ<code class="language-plaintext highlighter-rouge">limit</code>も試してみよう。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; User.limit(2000).find_each{|a|}
Scoped order and limit are ignored, it's forced to be batch order and batch size
  User Load (3.0ms)  SELECT  `users`.* FROM `users`  ORDER BY `users`.`id` ASC LIMIT 1000
  User Load (3.5ms)  SELECT  `users`.* FROM `users` WHERE (`users`.`id` &gt; 11003)  ORDER BY `users`.`id` ASC LIMIT 1000
  User Load (3.4ms)  SELECT  `users`.* FROM `users` WHERE (`users`.`id` &gt; 12003)  ORDER BY `users`.`id` ASC LIMIT 1000
  ...
</code></pre></div></div>

<p>やっぱりワーニングメッセージが出て無視された。</p>

<h2 id="where付き-find_each">where付き find_each</h2>

<p><code class="language-plaintext highlighter-rouge">where</code>を使って処理対象に条件を付けることもできます。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; User.where(notes: "1").find_each{|a|}
  User Load (4.3ms)  SELECT  `users`.* FROM `users` WHERE `users`.`notes` = '1'  ORDER BY `users`.`id` ASC LIMIT 1000
  User Load (4.8ms)  SELECT  `users`.* FROM `users` WHERE `users`.`notes` = '1' AND (`users`.`id` &gt; 11955)  ORDER BY `users`.`id` ASC LIMIT 1000
  User Load (4.9ms)  SELECT  `users`.* FROM `users` WHERE `users`.`notes` = '1' AND (`users`.`id` &gt; 13954)  ORDER BY `users`.`id` ASC LIMIT 1000
  User Load (4.7ms)  SELECT  `users`.* FROM `users` WHERE `users`.`notes` = '1' AND (`users`.`id` &gt; 18067)  ORDER BY `users`.`id` ASC LIMIT 1000
  ...
</code></pre></div></div>

<p>しっかり全てのクエリに<code class="language-plaintext highlighter-rouge">users</code>.<code class="language-plaintext highlighter-rouge">notes</code> = ‘1’という条件が付いていますね。</p>

<p>ところで、この`users`.`id` &gt; 11955 の<code class="language-plaintext highlighter-rouge">11955</code>というidはどこから出てきたんだろう？</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="n">records</span><span class="p">.</span><span class="nf">any?</span>
  <span class="n">records_size</span> <span class="o">=</span> <span class="n">records</span><span class="p">.</span><span class="nf">size</span>
  <span class="n">primary_key_offset</span> <span class="o">=</span> <span class="n">records</span><span class="p">.</span><span class="nf">last</span><span class="p">.</span><span class="nf">id</span>
  <span class="k">raise</span> <span class="s2">"Primary key not included in the custom select clause"</span> <span class="k">unless</span> <span class="n">primary_key_offset</span>

  <span class="k">yield</span> <span class="n">records</span>

  <span class="k">break</span> <span class="k">if</span> <span class="n">records_size</span> <span class="o">&lt;</span> <span class="n">batch_size</span>

  <span class="n">records</span> <span class="o">=</span> <span class="n">relation</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="n">primary_key</span><span class="p">].</span><span class="nf">gt</span><span class="p">(</span><span class="n">primary_key_offset</span><span class="p">)).</span><span class="nf">to_a</span>
<span class="k">end</span>
</code></pre></div></div>

<p>ポイントとなっているコード箇所を抜き出すとここ。</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">primary_key_offset</span> <span class="o">=</span> <span class="n">records</span><span class="p">.</span><span class="nf">last</span><span class="p">.</span><span class="nf">id</span>
<span class="n">relation</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="n">primary_key</span><span class="p">].</span><span class="nf">gt</span><span class="p">(</span><span class="n">primary_key_offset</span><span class="p">))</span>
</code></pre></div></div>

<p>最初に取得した1000件のうちの<code class="language-plaintext highlighter-rouge">last.id</code>を取得してそれより大きいidを条件として次の1000件を取得する、というようになっているようです。</p>

<h2 id="まとめ">まとめ</h2>

<ul>
  <li>find_eachはデフォルトで1000件ずつ処理する</li>
  <li>find_eachにおいてorderとlimitは無視される</li>
  <li>where付きの場合は1000件取得してその中のlast.idを使ってさらに次の1000件を取得してループを回していく</li>
</ul>

<h2 id="参考">参考</h2>
<ul>
  <li><a href="http://api.rubyonrails.org/classes/ActiveRecord/Batches.html">ActiveRecord::Batches</a></li>
</ul>]]></content><author><name>Toshimaru</name></author><category term="rails" /><category term="activerecord" /><summary type="html"><![CDATA[find_eachとは、バッチ処理などにおいてActiveRecordで効率的に大量データを処理したいときに使うメソッド。大量データ全部まるっと取ってきて処理しちゃあアカンよねってことで徐々に処理をしていくときに使う。]]></summary></entry><entry><title type="html">SQLファイルによるRails DBスキーマ管理</title><link href="https://blog.toshimaru.net/manage-schema-with-sql-in-rails/" rel="alternate" type="text/html" title="SQLファイルによるRails DBスキーマ管理" /><published>2015-07-03T00:00:00+09:00</published><updated>2019-11-10T00:00:00+09:00</updated><id>https://blog.toshimaru.net/manage-schema-with-sql-in-rails</id><content type="html" xml:base="https://blog.toshimaru.net/manage-schema-with-sql-in-rails/"><![CDATA[<p>Railsでは<code class="language-plaintext highlighter-rouge">db:migrate</code>すると、デフォルトで<code class="language-plaintext highlighter-rouge">db/schema.rb</code>を生成しますが、SQLでスキーマ情報を管理することも可能です。下記のように<code class="language-plaintext highlighter-rouge">config/application.rb</code>内で<code class="language-plaintext highlighter-rouge">active_record.schema_format</code>を<code class="language-plaintext highlighter-rouge">:sql</code>と設定することで可能になります（デフォルト値は<code class="language-plaintext highlighter-rouge">:ruby</code>）。</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># config/application.rb</span>
<span class="k">module</span> <span class="nn">RailsApp</span>
  <span class="k">class</span> <span class="nc">Application</span> <span class="o">&lt;</span> <span class="no">Rails</span><span class="o">::</span><span class="no">Application</span>
    <span class="n">config</span><span class="p">.</span><span class="nf">active_record</span><span class="p">.</span><span class="nf">schema_format</span> <span class="o">=</span> <span class="ss">:sql</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>これで<code class="language-plaintext highlighter-rouge">db/migrate</code>するとデフォルトの<code class="language-plaintext highlighter-rouge">schema.rb</code>ではなく、<code class="language-plaintext highlighter-rouge">db/structure.sql</code>というSQLファイルを吐きます。</p>

<h2 id="structuresqlをロードする">structure.sqlをロードする</h2>

<p>生成された<code class="language-plaintext highlighter-rouge">structure.sql</code>ファイルは、下記のコマンドでデータベースへロードできます。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>rails db:structure:load
</code></pre></div></div>

<h2 id="sqlファイルだけ欲しい場合">SQLファイルだけ欲しい場合</h2>

<p>SQLダンプファイルのみが欲しい場合は、<code class="language-plaintext highlighter-rouge">config.active_record.schema_format</code>の設定を変えずとも下記コマンドで<code class="language-plaintext highlighter-rouge">structure.sql</code>のみを生成することができます。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>rails db:structure:dump
</code></pre></div></div>

<h3 id="参考">参考</h3>

<ul>
  <li><a href="http://tech-kazuhisa.hatenablog.com/entry/20130902/1378126825">schema.rbじゃなくてstructure.sqlでスキーマ情報を管理しよう - tech-kazuhisa’s blog</a></li>
  <li><a href="http://edgeguides.rubyonrails.org/active_record_migrations.html#types-of-schema-dumps">Active Record Migrations — Ruby on Rails Guides</a></li>
</ul>]]></content><author><name>Toshimaru</name></author><category term="rails" /><category term="activerecord" /><summary type="html"><![CDATA[Railsではdb:migrateすると、デフォルトでdb/schema.rbを生成しますが、SQLでスキーマ情報を管理することも可能です。下記のようにconfig/application.rb内でactive_record.schema_formatを:sqlと設定することで可能になります（デフォルト値は:ruby）。]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://blog.toshimaru.net/images/posts/schema_format-sql-og.png" /><media:content medium="image" url="https://blog.toshimaru.net/images/posts/schema_format-sql-og.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">ActiveRecordのコールバックの順序・コールバック内のロールバック処理について</title><link href="https://blog.toshimaru.net/active-record-callbacks/" rel="alternate" type="text/html" title="ActiveRecordのコールバックの順序・コールバック内のロールバック処理について" /><published>2015-03-01T00:00:00+09:00</published><updated>2015-03-01T00:00:00+09:00</updated><id>https://blog.toshimaru.net/active-record-callbacks</id><content type="html" xml:base="https://blog.toshimaru.net/active-record-callbacks/"><![CDATA[<p>ActiveRecordのコールバックが実行される順序、およびそれらのタイミングでのロールバックするためのやり方をまとめてみました。</p>

<h2 id="callback-タイミング">Callback タイミング</h2>

<p>まずは順序について。下記のようになっています。</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">before_validation</code></li>
  <li><code class="language-plaintext highlighter-rouge">after_validation</code></li>
  <li><code class="language-plaintext highlighter-rouge">before_save</code></li>
  <li><code class="language-plaintext highlighter-rouge">before_create</code> or <code class="language-plaintext highlighter-rouge">before_update</code></li>
  <li><code class="language-plaintext highlighter-rouge">after_create</code> or <code class="language-plaintext highlighter-rouge">after_update</code></li>
  <li><code class="language-plaintext highlighter-rouge">after_save</code></li>
  <li><code class="language-plaintext highlighter-rouge">after_commit</code></li>
</ol>

<h2 id="実際にコードで試してみる">実際にコードで試してみる</h2>

<p>それぞれのコールバックをコードで試してみる。こんなコールバックを設定したUserモデルを作る。</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">before_validation</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">"before_validation is called"</span> <span class="p">}</span>
  <span class="n">after_validation</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">"after_validation is called"</span> <span class="p">}</span>
  <span class="n">before_save</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">"before_save is called"</span> <span class="p">}</span>
  <span class="n">before_update</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">"before_update is called"</span> <span class="p">}</span>
  <span class="n">before_create</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">"before_create is called"</span> <span class="p">}</span>
  <span class="n">after_create</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">"after_create is called"</span> <span class="p">}</span>
  <span class="n">after_update</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">"after_update is called"</span> <span class="p">}</span>
  <span class="n">after_save</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">"after_save is called"</span> <span class="p">}</span>
  <span class="n">after_commit</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">"after_commit is called"</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="新規レコード作成時">新規レコード作成時</h3>

<p>このモデルをnewしてsaveしてみる。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; User.new.save
   (0.1ms)  begin transaction
before_validation is called
after_validation is called
before_save is called
before_create is called
  SQL (0.6ms)  INSERT INTO "users" ("created_at", "updated_at") VALUES (?, ?)  [["created_at", "2015-02-28 15:53:53.000058"], ["updated_at", "2015-02-28 15:53:53.000058"]]
after_create is called
after_save is called
   (485.3ms)  commit transaction
after_commit is called
 =&gt; true
</code></pre></div></div>

<p>新規作成なので、更新時のコールバックである<code class="language-plaintext highlighter-rouge">before_update</code>, <code class="language-plaintext highlighter-rouge">after_update</code>は呼ばれない。</p>

<p>トランザクションが開始され<code class="language-plaintext highlighter-rouge">before_create</code>後にクエリが走る。その後、<code class="language-plaintext highlighter-rouge">after_save</code>のコールバックが呼ばれトランザクションがコミットされる。</p>

<h3 id="レコード更新時">レコード更新時</h3>

<p>同モデルのupdateの場合はこんな感じ。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; user.update(name: "toshi")
  (0.1ms)  begin transaction
before_validation is called
after_validation is called
before_save is called
before_update is called
 SQL (0.3ms)  UPDATE "users" SET "name" = ?, "updated_at" = ? WHERE "users"."id" = ?  [["name", "toshi"], ["updated_at", "2016-01-21 08:04:19.290079"], ["id", 1]]
after_update is called
after_save is called
   (2.5ms)  commit transaction
after_commit is called
=&gt; true
</code></pre></div></div>

<p>更新なので <code class="language-plaintext highlighter-rouge">before_create</code> <code class="language-plaintext highlighter-rouge">after_create</code> は呼ばれない。その代わりに<code class="language-plaintext highlighter-rouge">before_update</code>, <code class="language-plaintext highlighter-rouge">after_update</code>が実行される。</p>

<h2 id="saveupdate-はトランザクション内で実行される">save/update はトランザクション内で実行される</h2>

<p><a href="http://api.rubyonrails.org/classes/ActiveRecord/Callbacks.html">ドキュメント</a>にはこう書いてある。</p>

<blockquote>
  <p>The entire callback chain of a save, save!, or destroy call runs within a transaction. That includes after_* hooks. If everything goes fine a COMMIT is executed once the chain has been completed.</p>
</blockquote>

<p>つまり、<code class="language-plaintext highlighter-rouge">save</code>, <code class="language-plaintext highlighter-rouge">save!</code>, <code class="language-plaintext highlighter-rouge">destroy</code>のコールバック群はトランザクション内で処理され、全てのコールバックが問題なく通ればコミットされますよ、と。</p>

<h2 id="特定のコールバックのタイミングで処理をロールバックさせたい">特定のコールバックのタイミングで処理をロールバックさせたい</h2>

<p>それらのコールバックでの任意のタイミングでトランザクションをロールバックすることも可能。どうやれば良いのか調べてみた。</p>

<h3 id="before_-のタイミングでロールバックする場合">before_* のタイミングでロールバックする場合</h3>

<p><code class="language-plaintext highlighter-rouge">before_*</code>のタイミングで false を返すと処理はロールバックされる。</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">before_validation</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">"before_validation is called"</span> <span class="p">}</span>
  <span class="n">after_validation</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">"after_validation is called"</span> <span class="p">}</span>
  <span class="n">before_save</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">"before_save is called"</span><span class="p">;</span> <span class="kp">false</span> <span class="p">}</span>
  <span class="n">before_create</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">"before_create is called"</span> <span class="p">}</span>
  <span class="n">after_create</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">"after_create is called"</span> <span class="p">}</span>
  <span class="n">after_save</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">"after_save is called"</span> <span class="p">}</span>
  <span class="n">after_commit</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">"after_commit is called"</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; User.new.save
(0.1ms)  begin transaction
before_validation is called
after_validation is called
before_save is called
(0.1ms)  rollback transaction
=&gt; false
</code></pre></div></div>

<p>しかし<code class="language-plaintext highlighter-rouge">after_*</code>で false を返しても処理はロールバックされないようだ。</p>

<h3 id="after_-のタイミングでロールバックする場合">after_* のタイミングでロールバックする場合</h3>

<p>after_* のタイミングでロールバックしたい場合は、明示的にRollbackをraiseしてやれば :ok:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">before_validation</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">"before_validation is called"</span> <span class="p">}</span>
  <span class="n">after_validation</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">"after_validation is called"</span> <span class="p">}</span>
  <span class="n">before_save</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">"before_save is called"</span> <span class="p">}</span>
  <span class="n">before_create</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">"before_create is called"</span> <span class="p">}</span>
  <span class="n">after_create</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">"after_create is called"</span> <span class="p">}</span>
  <span class="n">after_save</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">"after_save is called"</span><span class="p">;</span> <span class="k">raise</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Rollback</span> <span class="p">}</span>
  <span class="n">after_commit</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">"after_commit is called"</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; User.new.save
   (0.1ms)  begin transaction
before_validation is called
after_validation is called
before_save is called
before_create is called
  SQL (0.4ms)  INSERT INTO "users" ("created_at", "updated_at") VALUES (?, ?)  [["created_at", "2015-02-28 16:49:35.344885"], ["updated_at", "2015-02-28 16:49:35.344885"]]
after_create is called
after_save is called
   (2.4ms)  rollback transaction
 =&gt; nil
</code></pre></div></div>

<p>update も同様にこの方法でロールバックできます。</p>

<h2 id="参考">参考</h2>

<ul>
  <li><a href="http://api.rubyonrails.org/classes/ActiveRecord/Callbacks.html">ActiveRecord::Callbacks</a></li>
  <li><a href="http://www.techscore.com/blog/2012/12/25/rails%E3%81%AE%E3%82%B3%E3%83%BC%E3%83%AB%E3%83%90%E3%83%83%E3%82%AF%E3%81%BE%E3%81%A8%E3%82%81/">» Railsのコールバックまとめ TECHSCORE BLOG</a></li>
</ul>]]></content><author><name>Toshimaru</name></author><category term="rails" /><category term="activerecord" /><summary type="html"><![CDATA[ActiveRecordのコールバックが実行される順序、およびそれらのタイミングでのロールバックするためのやり方をまとめてみました。]]></summary></entry><entry><title type="html">Rails でトランザクション分離レベルを設定する方法</title><link href="https://blog.toshimaru.net/rails-4-transaction-isolation/" rel="alternate" type="text/html" title="Rails でトランザクション分離レベルを設定する方法" /><published>2015-01-19T00:00:00+09:00</published><updated>2019-09-21T00:00:00+09:00</updated><id>https://blog.toshimaru.net/rails-4-transaction-isolation</id><content type="html" xml:base="https://blog.toshimaru.net/rails-4-transaction-isolation/"><![CDATA[<div class="info">
  <h5>追記</h5>
  <p>Rails5, Rails6 向けに記事の内容をアップデートしました（2019/09/21）</p>
</div>

<h2 id="mysqlのトランザクション分離レベル">MySQLのトランザクション分離レベル</h2>

<p>突然ですが問題です。MySQLのデフォルトのトランザクション分離レベルは何でしょうか？</p>

<blockquote>
  <p><strong>REPEATABLE READ</strong></p>

  <p>This is the default isolation level for InnoDB.</p>
</blockquote>

<p>via. <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_repeatable-read">MySQL :: MySQL 8.0 Reference Manual :: 15.7.2.1 Transaction Isolation Levels</a></p>

<p>ハイ、答えは「<strong>REPEATABLE READ</strong>」ですネ。</p>

<h2 id="railsでトランザクション分離レベルを設定">Railsでトランザクション分離レベルを設定</h2>

<p>続いての問題です。Railsにおいてトランザクション分離レベルを設定するにはどうしたらよいでしょうか？ 実は Rails 3 と Rails 4 と Rails 5 以降ではトランザクション分離レベルの設定方法はそれぞれ異なっています。</p>

<h3 id="rails-3">Rails 3</h3>

<p>Rails 3の時代では <code class="language-plaintext highlighter-rouge">execute</code> で直接トランザクション分離レベルを設定する必要がありました。</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">.</span><span class="nf">connection</span><span class="p">.</span><span class="nf">execute</span><span class="p">(</span><span class="s1">'SET TRANSACTION ISOLATION LEVEL READ COMMITTED'</span><span class="p">)</span>
<span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">.</span><span class="nf">transaction</span> <span class="k">do</span>
  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="rails-4x">Rails 4.x</h3>

<p>Rails 4からは<code class="language-plaintext highlighter-rouge">transaction</code>のオプションとしてトランザクション分離レベルを設定可能になりました。</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">.</span><span class="nf">transaction</span><span class="p">(</span><span class="ss">isolation: :read_committed</span><span class="p">)</span> <span class="k">do</span>
  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="rails-5-以降">Rails 5 以降</h3>

<p>Rails 5からは <code class="language-plaintext highlighter-rouge">ActiveRecord::Base</code> の代わりに <code class="language-plaintext highlighter-rouge">ApplicationRecord</code> が使うことができます。</p>

<blockquote>
  <p>ApplicationRecord is a new superclass for all app models</p>
</blockquote>

<p>via. <a href="https://edgeguides.rubyonrails.org/5_0_release_notes.html">Ruby on Rails 5.0 Release Notes — Ruby on Rails Guides</a></p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">ApplicationRecord</span><span class="p">.</span><span class="nf">transaction</span><span class="p">(</span><span class="ss">isolation: :read_committed</span><span class="p">)</span> <span class="k">do</span> 
  <span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">lock</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">user</span><span class="p">.</span><span class="nf">update!</span> <span class="ss">name: </span><span class="s2">"TEST"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上記のコードを pry で実行した際に流れるクエリは下記の通りです。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   (0.5ms)  SET TRANSACTION ISOLATION LEVEL READ COMMITTED
   (0.3ms)  BEGIN
  User Load (0.9ms)  SELECT  `users`.* FROM `users` WHERE `users`.`id` = 1 LIMIT 1 FOR UPDATE
  User Update (0.4ms)  UPDATE `users` SET `name` = 'TEST', `updated_at` = '2019-09-20 16:34:31' WHERE `users`.`id` = 1
   (1.5ms)  COMMIT
=&gt; true
</code></pre></div></div>

<h2 id="有効なトランザクション分離レベル">有効なトランザクション分離レベル</h2>

<p>Railsで設定可能かつ有効な<code class="language-plaintext highlighter-rouge">isolation</code>レベルは何でしょうか？　答えは下記４つになります。</p>

<blockquote>
  <p>Valid isolation levels are:</p>

  <ul>
    <li><code class="language-plaintext highlighter-rouge">:read_uncommitted</code></li>
    <li><code class="language-plaintext highlighter-rouge">:read_committed</code></li>
    <li><code class="language-plaintext highlighter-rouge">:repeatable_read</code></li>
    <li><code class="language-plaintext highlighter-rouge">:serializable</code></li>
  </ul>
</blockquote>

<p>via. <a href="https://railsdoc.github.io/classes/ActiveRecord/ConnectionAdapters/DatabaseStatements.html#method-i-transaction-label-Transaction+isolation">ActiveRecord::ConnectionAdapters::DatabaseStatements | RailsDoc</a></p>

<h2 id="分離レベルとダーティリードファジーリードファントムリードの関係">分離レベルとダーティリード、ファジーリード、ファントムリードの関係</h2>

<p>分離レベルとダーティリード、ファジーリード、ファントムリードそれぞれの関係性は以下の通り。</p>

<table>
  <thead>
    <tr>
      <th>トランザクション分離レベル</th>
      <th>ダーティリード</th>
      <th>ファジーリード</th>
      <th>ファントムリード</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>READ UNCOMMITTED</strong></td>
      <td>💀発生する</td>
      <td>💀発生する</td>
      <td>💀発生する</td>
    </tr>
    <tr>
      <td><strong>READ COMMITTED</strong></td>
      <td>発生しない</td>
      <td>💀発生する</td>
      <td>💀発生する</td>
    </tr>
    <tr>
      <td><strong>REPEATABLE READ</strong></td>
      <td>発生しない</td>
      <td>発生しない</td>
      <td>💀発生する</td>
    </tr>
    <tr>
      <td><strong>SERIALIZABLE</strong></td>
      <td>発生しない</td>
      <td>発生しない</td>
      <td>発生しない</td>
    </tr>
  </tbody>
</table>

<p>via. <a href="https://qiita.com/PruneMazui/items/4135fcf7621869726b4b">[RDBMS][SQL]トランザクション分離レベルについて極力分かりやすく解説 - Qiita</a></p>

<h2 id="最後に">最後に</h2>

<p>適切なトランザクション分離レベルで適切なトランザクション処理をしましょう！</p>

<h2 id="参考">参考</h2>

<ul>
  <li><a href="https://tkrd.hatenadiary.org/entry/20131121/1385044179">Rails &amp; MySQL: トランザクション分離レベルをグローバルに設定する</a></li>
  <li><a href="https://railsdoc.github.io/classes/ActiveRecord/ConnectionAdapters/DatabaseStatements.html#method-i-transaction-label-Transaction+isolation">ActiveRecord::ConnectionAdapters::DatabaseStatements | RailsDoc</a></li>
  <li><a href="https://qiita.com/PruneMazui/items/4135fcf7621869726b4b">[RDBMS][SQL]トランザクション分離レベルについて極力分かりやすく解説 - Qiita</a></li>
</ul>]]></content><author><name>Toshimaru</name></author><category term="rails" /><category term="activerecord" /><category term="mysql" /><summary type="html"><![CDATA[突然ですが問題です。MySQLのデフォルトのトランザクション分離レベルは何でしょうか？　続いての問題です。Railsにおいてトランザクション分離レベルを設定するにはどうしたらよいでしょうか？ 実は Rails 3 と Rails 4 と Rails 5 以降ではトランザクション分離レベルの設定方法はそれぞれ異なっています。]]></summary></entry><entry><title type="html">ActiveRecordでhas_many, throughとは逆の関連を定義する</title><link href="https://blog.toshimaru.net/belongs_to-through/" rel="alternate" type="text/html" title="ActiveRecordでhas_many, throughとは逆の関連を定義する" /><published>2014-08-12T00:00:00+09:00</published><updated>2019-11-04T00:00:00+09:00</updated><id>https://blog.toshimaru.net/belongs_to-through</id><content type="html" xml:base="https://blog.toshimaru.net/belongs_to-through/"><![CDATA[<h2 id="tldr">TL;DR</h2>

<p><code class="language-plaintext highlighter-rouge">has_many</code>+<code class="language-plaintext highlighter-rouge">through</code>の逆の関連の定義には:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">belongs_to</code>+<code class="language-plaintext highlighter-rouge">through</code>は使えない</li>
  <li><code class="language-plaintext highlighter-rouge">delegate</code> or <code class="language-plaintext highlighter-rouge">has_one</code>+<code class="language-plaintext highlighter-rouge">through</code> が使える</li>
  <li><code class="language-plaintext highlighter-rouge">has_one</code>+<code class="language-plaintext highlighter-rouge">through</code> の方が効率もよく、 <code class="language-plaintext highlighter-rouge">includes</code> も使えてオススメ</li>
</ul>

<h2 id="テーブル構成">テーブル構成</h2>

<p>とあるRailsアプリケーションでこんなテーブル構成があったとします。</p>

<p><img src="/images/posts/has-many-through/user-post-comment.png" alt="User Post Comment" /></p>

<h3 id="railsモデル構成">Railsモデル構成</h3>

<p>ユーザー（<code class="language-plaintext highlighter-rouge">User</code>）は複数の記事（<code class="language-plaintext highlighter-rouge">Post</code>）をもっていて、その記事は複数のコメント（<code class="language-plaintext highlighter-rouge">Comment</code>）を持っている、という状態です。</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">has_many</span> <span class="ss">:posts</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Post</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">belongs_to</span> <span class="ss">:user</span>
  <span class="n">has_many</span> <span class="ss">:comments</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Comment</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">belongs_to</span> <span class="ss">:post</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="has_many-through-の定義">has_many, through の定義</h2>

<p>上記のようなモデル定義においてユーザーモデルから直接コメントモデルへの関連を定義するにはどうしたらよいでしょうか？</p>

<p>答えは<code class="language-plaintext highlighter-rouge">has_many</code>+<code class="language-plaintext highlighter-rouge">through</code>を使うことです。</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">has_many</span> <span class="ss">:posts</span>
  <span class="n">has_many</span> <span class="ss">:comments</span><span class="p">,</span> <span class="ss">through: :posts</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Post</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">belongs_to</span> <span class="ss">:user</span>
  <span class="n">has_many</span> <span class="ss">:comments</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Comment</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">belongs_to</span> <span class="ss">:post</span>
<span class="k">end</span>
</code></pre></div></div>

<p>下記一行が変更点となります。</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">has_many</span> <span class="ss">:comments</span><span class="p">,</span> <span class="ss">through: :posts</span>
</code></pre></div></div>

<p>この変更により、特定のユーザーがどんなコメントを持っているかを下記のように一発で引くことができるようになりました。</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="c1"># User Load (0.3ms)  SELECT  `users`.* FROM `users` WHERE `users`.`id` = 1 LIMIT 1</span>
<span class="n">user</span><span class="p">.</span><span class="nf">comments</span>
<span class="c1"># Comment Load (0.5ms)  SELECT  `comments`.* FROM `comments` INNER JOIN `posts` ON `comments`.`post_id` = `posts`.`id` WHERE `posts`.`user_id` = 1 LIMIT 11</span>
</code></pre></div></div>

<p>ではここで疑問。逆にコメントモデルから<code class="language-plaintext highlighter-rouge">Post</code>モデルを省いてユーザーを引くことはできないのでしょうか？ つまり <strong><code class="language-plaintext highlighter-rouge">has_many</code>, <code class="language-plaintext highlighter-rouge">through</code>の逆の関連はどう定義したらよいのでしょうか？</strong></p>

<h3 id="belongs_to-through-は使えない">belongs_to, through は使えない？</h3>

<p><code class="language-plaintext highlighter-rouge">has_many</code>, <code class="language-plaintext highlighter-rouge">through</code>が使えるんだから <code class="language-plaintext highlighter-rouge">belongs_to</code>, <code class="language-plaintext highlighter-rouge">through</code> も使えると思うでしょう？　しかし実際に動かしてみると下記のエラーが発生してしまします。</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Comment</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">belongs_to</span> <span class="ss">:post</span>
  <span class="n">belongs_to</span> <span class="ss">:user</span><span class="p">,</span> <span class="ss">through: :post</span>
<span class="k">end</span>
<span class="c1"># =&gt; ArgumentError (Unknown key: :through. Valid keys are: :class_name, ...</span>
</code></pre></div></div>

<p>残念ながら<code class="language-plaintext highlighter-rouge">belongs_to</code>には<code class="language-plaintext highlighter-rouge">through</code>というオプションは無いようです。</p>

<p><code class="language-plaintext highlighter-rouge">has_many</code>, <code class="language-plaintext highlighter-rouge">through</code>の逆の関連を定義するには２つの方法があります。</p>

<h2 id="1-delegate-を使う方法">1. delegate を使う方法</h2>

<p>１つ目の方法は<code class="language-plaintext highlighter-rouge">delegate</code>を使うことです。具体的にはコメントモデルを下記のように変更します。</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">has_many</span> <span class="ss">:posts</span>
  <span class="n">has_many</span> <span class="ss">:comments</span><span class="p">,</span> <span class="ss">through: :posts</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Post</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">belongs_to</span> <span class="ss">:user</span>
  <span class="n">has_many</span> <span class="ss">:comments</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Comment</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">belongs_to</span> <span class="ss">:post</span>
  <span class="n">delegate</span> <span class="ss">:user</span><span class="p">,</span> <span class="ss">to: :post</span>
<span class="k">end</span>
</code></pre></div></div>

<p>下記のようにユーザーを引くことができるようになりました。</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="no">Comment</span><span class="p">.</span><span class="nf">first</span><span class="p">.</span><span class="nf">user</span>
<span class="c1">#  Comment Load (0.3ms)  SELECT  `comments`.* FROM `comments` ORDER BY `comments`.`id` ASC LIMIT 1</span>
<span class="c1">#  Post Load (0.4ms)  SELECT  `posts`.* FROM `posts` WHERE `posts`.`id` = 1 LIMIT 1</span>
<span class="c1">#  User Load (0.3ms)  SELECT  `users`.* FROM `users` WHERE `users`.`id` = 1 LIMIT 1</span>
<span class="o">=&gt;</span> <span class="c1">#&lt;User id: 1, name: "TEST", created_at: "2019-09-20 15:36:46", updated_at: "2019-09-20 16:34:31"&gt;</span>
</code></pre></div></div>

<p>ご覧のように Comment → Post → User と順にロードされていることがわかります。</p>

<h2 id="2-has_one-through-を使う方法">2. has_one, through を使う方法</h2>

<p>２つ目の方法は<code class="language-plaintext highlighter-rouge">has_one</code>, <code class="language-plaintext highlighter-rouge">through</code>を使うことです。コメントモデルを下記のように変更します。</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">has_many</span> <span class="ss">:posts</span>
  <span class="n">has_many</span> <span class="ss">:comments</span><span class="p">,</span> <span class="ss">through: :posts</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Post</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">belongs_to</span> <span class="ss">:user</span>
  <span class="n">has_many</span> <span class="ss">:comments</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Comment</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">belongs_to</span> <span class="ss">:post</span>
  <span class="n">has_one</span> <span class="ss">:user</span><span class="p">,</span> <span class="ss">through: :post</span>
<span class="k">end</span>
</code></pre></div></div>

<p>こちらも同様に下記のようにユーザーを引くことができるようになりました。</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="no">Comment</span><span class="p">.</span><span class="nf">first</span><span class="p">.</span><span class="nf">user</span>
<span class="c1">#  Comment Load (0.3ms)  SELECT  `comments`.* FROM `comments` ORDER BY `comments`.`id` ASC LIMIT 1</span>
<span class="c1">#  User Load (0.4ms)  SELECT  `users`.* FROM `users` INNER JOIN `posts` ON `users`.`id` = `posts`.`user_id` WHERE `posts`.`id` = 1 LIMIT 1</span>
<span class="o">=&gt;</span> <span class="c1">#&lt;User id: 1, name: "TEST", created_at: "2019-09-20 15:36:46", updated_at: "2019-09-20 16:34:31"&gt;</span>
</code></pre></div></div>

<p>こちらの方法の定義だと、SQLおよびモデルのLoadが<code class="language-plaintext highlighter-rouge">delegate</code>方式よりも一回分少なく済むので、より低コストでコメントからユーザーを引くことができます。</p>

<h3 id="includes-も使うことができる">includes も使うことができる</h3>

<p><code class="language-plaintext highlighter-rouge">has_one</code> で定義していると <code class="language-plaintext highlighter-rouge">includes</code> も使うことができます。</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="no">Comment</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="ss">:user</span><span class="p">).</span><span class="nf">find</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="c1">#  Comment Load (2.9ms)  SELECT  `comments`.* FROM `comments` WHERE `comments`.`id` = 1 LIMIT 1</span>
<span class="c1">#  Post Load (0.5ms)  SELECT `posts`.* FROM `posts` WHERE `posts`.`id` = 1</span>
<span class="c1">#  User Load (0.4ms)  SELECT `users`.* FROM `users` WHERE `users`.`id` = 1</span>
<span class="o">=&gt;</span> <span class="c1">#&lt;Comment id: 1, ...</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">eager_load</code>や<code class="language-plaintext highlighter-rouge">joins</code>も同様に使うことができます。</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="no">Comment</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:user</span><span class="p">).</span><span class="nf">find</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="c1">#  Comment Load (1.0ms)  SELECT  `comments`.* FROM `comments` INNER JOIN `posts` ON `posts`.`id` = `comments`.`post_id` INNER JOIN `users` ON `users`.`id` = `posts`.`user_id` WHERE `comments`.`id` = 1 LIMIT 1</span>
<span class="o">=&gt;</span> <span class="c1">#&lt;Comment id: 1 ...</span>
<span class="o">&gt;</span> <span class="no">Comment</span><span class="p">.</span><span class="nf">eager_load</span><span class="p">(</span><span class="ss">:user</span><span class="p">).</span><span class="nf">find</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="c1">#  SQL (2.4ms)  SELECT  `comments`.`id` AS t0_r0, `comments`.`post_id` AS t0_r1, `comments`.`content` AS t0_r2, `comments`.`created_at` AS t0_r3, `comments`.`updated_at` AS t0_r4, `ube sers`.`id` AS t1_r0, `users`.`name` AS t1_r1, `users`.`created_at` AS t1_r2, `users`.`updated_at` AS t1_r3 FROM `comments` LEFT OUTER JOIN `posts` ON `posts`.`id` = `comments`.`post_id` LEFT OUTER JOIN `users` ON `users`.`id` = `posts`.`user_id` WHERE `comments`.`id` = 1 LIMIT 1</span>
<span class="o">=&gt;</span> <span class="c1">#&lt;Comment id: 1 ...</span>
</code></pre></div></div>

<h2 id="どちらの方法が良いか">どちらの方法が良いか？</h2>

<table>
  <thead>
    <tr>
      <th> </th>
      <th><code class="language-plaintext highlighter-rouge">delegate</code></th>
      <th><code class="language-plaintext highlighter-rouge">has_one</code>+<code class="language-plaintext highlighter-rouge">through</code></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Comment</code> → <code class="language-plaintext highlighter-rouge">User</code> 参照のための総クエリ回数</td>
      <td>3回</td>
      <td>2回</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">includes</code> <code class="language-plaintext highlighter-rouge">joins</code> などが使えるか？</td>
      <td>☓ 使用不可</td>
      <td>○ 使用可</td>
    </tr>
    <tr>
      <td>定義の意味</td>
      <td><code class="language-plaintext highlighter-rouge">comment</code> から<br /><code class="language-plaintext highlighter-rouge">user</code> への関連を<br /><code class="language-plaintext highlighter-rouge">post</code> に移譲</td>
      <td><code class="language-plaintext highlighter-rouge">comment</code> は<br /><code class="language-plaintext highlighter-rouge">post</code>を通して<br /><code class="language-plaintext highlighter-rouge">user</code>への関連を１つ持つ</td>
    </tr>
  </tbody>
</table>

<p>ということで <code class="language-plaintext highlighter-rouge">delegate</code> よりは  <code class="language-plaintext highlighter-rouge">has_one</code>+<code class="language-plaintext highlighter-rouge">through</code> を使うのがオススメです。</p>

<h2 id="参考">参考</h2>

<ul>
  <li><a href="http://stackoverflow.com/questions/4021322/belongs-to-through-associations">belongs_to through associations</a></li>
  <li><a href="https://apidock.com/rails/Module/delegate">delegate (Module) - APIdock</a></li>
  <li><a href="https://railsdoc.github.io/classes/ActiveRecord/Associations/ClassMethods.html#method-i-has_one">ActiveRecord::Associations::ClassMethods | RailsDoc</a></li>
</ul>]]></content><author><name>Toshimaru</name></author><category term="activerecord" /><category term="rails" /><summary type="html"><![CDATA[とあるRailsアプリケーションでこんなテーブル構成があったとします。ユーザー（User）は複数の記事（Post）をもっていて、その記事は複数のコメント（Comment）を持っている、という状態です。上記のようなモデル定義においてユーザーモデルから直接コメントモデルへの関連を定義するにはどうしたらよいでしょうか？ 答えはhas_many+throughを使うことです。has_many, throughの逆の関連はどう定義したらよいのでしょうか？]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://blog.toshimaru.net/images/posts/has-many-through/og.png" /><media:content medium="image" url="https://blog.toshimaru.net/images/posts/has-many-through/og.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>